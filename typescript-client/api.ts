/* tslint:disable */
/* eslint-disable */
/**
 * Juniper Square Internal API
 * An internal API for inter-service communication at JSQ.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Account contact bulk success response
 * @export
 * @interface AccountContactBulkSuccessResponse
 */
export interface AccountContactBulkSuccessResponse {
    /**
     * Arena ID
     * @type {number}
     * @memberof AccountContactBulkSuccessResponse
     */
    'arena_id'?: number;
    /**
     * User ID
     * @type {number}
     * @memberof AccountContactBulkSuccessResponse
     */
    'account_id'?: number;
    /**
     * Account contact ID
     * @type {number}
     * @memberof AccountContactBulkSuccessResponse
     */
    'account_contact_id'?: number;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof AccountContactBulkSuccessResponse
     */
    'status'?: ResponseStatus;
}


/**
 * Address for business
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Street address
     * @type {string}
     * @memberof Address
     */
    'line1'?: string;
    /**
     * Street address line 2
     * @type {string}
     * @memberof Address
     */
    'line2'?: string | null;
    /**
     * City
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * State
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof Address
     */
    'postal_code'?: string;
    /**
     * Country (ISO 3166-1 alpha-2)
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
}
/**
 * Allocation Types for an arena
 * @export
 * @interface AllocationType
 */
export interface AllocationType {
    /**
     * Name of the allocation type.
     * @type {string}
     * @memberof AllocationType
     */
    'name': string;
    /**
     * Category of the allocation type.
     * @type {string}
     * @memberof AllocationType
     */
    'category': AllocationTypeCategoryEnum;
    /**
     * Flag to indicate whether the allocation type is recallable.
     * @type {boolean}
     * @memberof AllocationType
     */
    'is_recallable': boolean;
}

export const AllocationTypeCategoryEnum = {
    CapitalCall: 'Capital Call',
    CapitalActivity: 'Capital Activity',
    DistributionAllocations: 'Distribution Allocations',
    NetIncomeAllocations: 'Net Income Allocations'
} as const;

export type AllocationTypeCategoryEnum = typeof AllocationTypeCategoryEnum[keyof typeof AllocationTypeCategoryEnum];

/**
 * Arena resources representing a GP workspace.
 * @export
 * @interface Arena
 */
export interface Arena {
    /**
     * 
     * @type {number}
     * @memberof Arena
     */
    'id': number;
    /**
     * The name of the arena.
     * @type {string}
     * @memberof Arena
     */
    'name': string;
    /**
     * The environment specific arena\'s hostname and path prefix for the Unified Portal (Portal 2.0)
     * @type {string}
     * @memberof Arena
     */
    'unified_portal_url': string;
    /**
     * Whether the arena is active.
     * @type {boolean}
     * @memberof Arena
     */
    'is_active': boolean;
    /**
     * The domain of the arena.
     * @type {string}
     * @memberof Arena
     */
    'domain': string;
}
/**
 * Allocation Type for an arena.
 * @export
 * @interface ArenaNetIncomeType
 */
export interface ArenaNetIncomeType {
    /**
     * FK to the the arena these payment settings belong to.
     * @type {number}
     * @memberof ArenaNetIncomeType
     */
    'arena_id': number;
    /**
     * ID of the allocation type.
     * @type {number}
     * @memberof ArenaNetIncomeType
     */
    'id': number;
    /**
     * The sort order of the object.
     * @type {number}
     * @memberof ArenaNetIncomeType
     */
    'sort_order'?: number;
    /**
     * Name of the allocation type.
     * @type {string}
     * @memberof ArenaNetIncomeType
     */
    'name': string;
}
/**
 * Payment Settings for an arena.
 * @export
 * @interface ArenaPaymentSettings
 */
export interface ArenaPaymentSettings {
    /**
     * FK to the the arena these payment settings belong to.
     * @type {number}
     * @memberof ArenaPaymentSettings
     */
    'arena_id': number;
    /**
     * The number of approvers required on a payment batch.
     * @type {number}
     * @memberof ArenaPaymentSettings
     */
    'required_approval_count': number;
    /**
     * Whether or not the payment batch creator can also approve the payment batch.
     * @type {boolean}
     * @memberof ArenaPaymentSettings
     */
    'require_different_approver': boolean;
}
/**
 * Roles for an arena.
 * @export
 * @interface ArenaRoles
 */
export interface ArenaRoles {
    /**
     * FK to the arena.
     * @type {number}
     * @memberof ArenaRoles
     */
    'arena_id': number;
    /**
     * FK to the role.
     * @type {Array<number>}
     * @memberof ArenaRoles
     */
    'role_ids': Array<number>;
    /**
     * Enum key for the role. Orders sorted by role name alphabetical order.
     * @type {Array<string>}
     * @memberof ArenaRoles
     */
    'role_enums': Array<string>;
}
/**
 * A bank account
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
    /**
     * ID of the bank account.
     * @type {number}
     * @memberof BankAccount
     */
    'id': number;
    /**
     * Name of the bank account owner.
     * @type {string}
     * @memberof BankAccount
     */
    'owner_name': string;
    /**
     * Bank account number.
     * @type {string}
     * @memberof BankAccount
     */
    'account_number': string;
    /**
     * Bank account routing number.
     * @type {string}
     * @memberof BankAccount
     */
    'routing_number': string;
    /**
     * Arena ID this bank account belongs to.
     * @type {number}
     * @memberof BankAccount
     */
    'arena_id': number;
    /**
     * 
     * @type {BankAccountAchInfo}
     * @memberof BankAccount
     */
    'ach_info'?: BankAccountAchInfo | null;
}
/**
 * A bank account containing ach specific info. This will only have valid fields if the bank account is set to ach. 
 * @export
 * @interface BankAccountAchInfo
 */
export interface BankAccountAchInfo {
    /**
     * Optional ach account owner name
     * @type {string}
     * @memberof BankAccountAchInfo
     */
    'ach_instructions_account_owner_name'?: string | null;
}
/**
 * 
 * @export
 * @interface BulkAccountContactChangeNotify
 */
export interface BulkAccountContactChangeNotify {
    /**
     * 
     * @type {string}
     * @memberof BulkAccountContactChangeNotify
     */
    'request_type'?: BulkAccountContactChangeNotifyRequestTypeEnum;
    /**
     * 
     * @type {Array<BulkAccountContactChangeNotifyRequestPayloadsInner>}
     * @memberof BulkAccountContactChangeNotify
     */
    'request_payloads'?: Array<BulkAccountContactChangeNotifyRequestPayloadsInner>;
}

export const BulkAccountContactChangeNotifyRequestTypeEnum = {
    AddContact: 'ADD_CONTACT',
    UpdateContact: 'UPDATE_CONTACT',
    RemoveContact: 'REMOVE_CONTACT'
} as const;

export type BulkAccountContactChangeNotifyRequestTypeEnum = typeof BulkAccountContactChangeNotifyRequestTypeEnum[keyof typeof BulkAccountContactChangeNotifyRequestTypeEnum];

/**
 * 
 * @export
 * @interface BulkAccountContactChangeNotifyRequestPayloadsInner
 */
export interface BulkAccountContactChangeNotifyRequestPayloadsInner {
    /**
     * 
     * @type {number}
     * @memberof BulkAccountContactChangeNotifyRequestPayloadsInner
     */
    'arena_id': number;
    /**
     * 
     * @type {number}
     * @memberof BulkAccountContactChangeNotifyRequestPayloadsInner
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof BulkAccountContactChangeNotifyRequestPayloadsInner
     */
    'contact_id': number;
    /**
     * 
     * @type {string}
     * @memberof BulkAccountContactChangeNotifyRequestPayloadsInner
     */
    'comment': string;
}
/**
 * Bulk account contact removal object
 * @export
 * @interface BulkAccountContactRemove
 */
export interface BulkAccountContactRemove {
    /**
     * Arena ID
     * @type {number}
     * @memberof BulkAccountContactRemove
     */
    'arena_id': number;
    /**
     * User ID
     * @type {number}
     * @memberof BulkAccountContactRemove
     */
    'account_id': number;
    /**
     * Account contact ID
     * @type {number}
     * @memberof BulkAccountContactRemove
     */
    'account_contact_id': number;
}
/**
 * Bulk account contact removal array input
 * @export
 * @interface BulkAccountContactRemoveRequestBody
 */
export interface BulkAccountContactRemoveRequestBody {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BulkAccountContactRemoveRequestBody
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<BulkAccountContactRemove>}
     * @memberof BulkAccountContactRemoveRequestBody
     */
    'request_payloads'?: Array<BulkAccountContactRemove>;
}
/**
 * Bulk account contact update
 * @export
 * @interface BulkAccountContactUpdate
 */
export interface BulkAccountContactUpdate {
    /**
     * Arena ID
     * @type {number}
     * @memberof BulkAccountContactUpdate
     */
    'arena_id': number;
    /**
     * User ID
     * @type {number}
     * @memberof BulkAccountContactUpdate
     */
    'account_id': number;
    /**
     * Account contact ID
     * @type {number}
     * @memberof BulkAccountContactUpdate
     */
    'account_contact_id': number;
    /**
     * Relationship label for account contact
     * @type {string}
     * @memberof BulkAccountContactUpdate
     */
    'label'?: string | null;
    /**
     * True if the account contact is To contact, False for CC contact
     * @type {boolean}
     * @memberof BulkAccountContactUpdate
     */
    'is_main_contact'?: boolean | null;
    /**
     * True if the account contact is an admin contact
     * @type {boolean}
     * @memberof BulkAccountContactUpdate
     */
    'is_admin_contact'?: boolean | null;
    /**
     * List of distribution IDs
     * @type {Array<number>}
     * @memberof BulkAccountContactUpdate
     */
    'distribution_list'?: Array<number> | null;
}
/**
 * Bulk account contact update array input
 * @export
 * @interface BulkAccountContactUpdateRequestBody
 */
export interface BulkAccountContactUpdateRequestBody {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BulkAccountContactUpdateRequestBody
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<BulkAccountContactUpdate>}
     * @memberof BulkAccountContactUpdateRequestBody
     */
    'request_payloads'?: Array<BulkAccountContactUpdate>;
}
/**
 * @type BulkUpdateDeveloperFeatureFlags400Response
 * @export
 */
export type BulkUpdateDeveloperFeatureFlags400Response = Array<Error> | ModelError;

/**
 * Bulk operation to update feature flag states in bulk.
 * @export
 * @interface BulkUpdateFeatureFlags
 */
export interface BulkUpdateFeatureFlags {
    [key: string]: boolean;

}
/**
 * Business information for diligence
 * @export
 * @interface BusinessInfo
 */
export interface BusinessInfo {
    /**
     * Profile ID for diligence
     * @type {number}
     * @memberof BusinessInfo
     */
    'external_profile_id'?: number;
    /**
     * Legal entity name
     * @type {string}
     * @memberof BusinessInfo
     */
    'legal_entity_name'?: string;
    /**
     * Date of formation for business
     * @type {string}
     * @memberof BusinessInfo
     */
    'date_of_organization'?: string;
    /**
     * Tax ID for business
     * @type {string}
     * @memberof BusinessInfo
     */
    'tax_id'?: string | null;
    /**
     * Documents for business
     * @type {Array<BusinessInfoDocumentsInner>}
     * @memberof BusinessInfo
     */
    'documents'?: Array<BusinessInfoDocumentsInner>;
    /**
     * 
     * @type {BusinessInfoAddress}
     * @memberof BusinessInfo
     */
    'address'?: BusinessInfoAddress | null;
    /**
     * Individual profiles used for legacy diligences. This is deprecated. For KYC, a KycDetail will be created. For watchlist, a watchlist screening will be triggered.
     * @type {Array<BusinessInfoIndividualProfilesInner>}
     * @memberof BusinessInfo
     */
    'individual_profiles'?: Array<BusinessInfoIndividualProfilesInner>;
    /**
     * Institution profiles used for legacy diligences. This is deprecated. For KYC, a KycDetail will be created. For watchlist, a watchlist screening will be triggered.
     * @type {Array<BusinessInfoInstitutionProfilesInner>}
     * @memberof BusinessInfo
     */
    'institution_profiles'?: Array<BusinessInfoInstitutionProfilesInner>;
}
/**
 * @type BusinessInfoAddress
 * Address for business
 * @export
 */
export type BusinessInfoAddress = Address;

/**
 * @type BusinessInfoDocumentsInner
 * @export
 */
export type BusinessInfoDocumentsInner = Document;

/**
 * @type BusinessInfoIndividualProfilesInner
 * @export
 */
export type BusinessInfoIndividualProfilesInner = IndividualProfile;

/**
 * @type BusinessInfoInstitutionProfilesInner
 * @export
 */
export type BusinessInfoInstitutionProfilesInner = InstitutionProfile;

/**
 * Deprecated create diligence object and underlying KYC/watchlists
 * @export
 * @interface CreateDiligence
 */
export interface CreateDiligence {
    /**
     * Arena ID the diligence is located in
     * @type {number}
     * @memberof CreateDiligence
     */
    'arena_id'?: number;
    /**
     * User ID of the user creating the diligence
     * @type {number}
     * @memberof CreateDiligence
     */
    'user_id'?: number;
    /**
     * 
     * @type {CreateDiligenceExternalObjectType}
     * @memberof CreateDiligence
     */
    'external_object_type'?: CreateDiligenceExternalObjectType;
    /**
     * Number representing the id of the external object type in the external object type table.
     * @type {number}
     * @memberof CreateDiligence
     */
    'external_object_id'?: number;
    /**
     * 
     * @type {CreateDiligenceDiligenceType}
     * @memberof CreateDiligence
     */
    'diligence_type'?: CreateDiligenceDiligenceType;
    /**
     * 
     * @type {CreateDiligenceDiligenceCategory}
     * @memberof CreateDiligence
     */
    'diligence_category'?: CreateDiligenceDiligenceCategory;
    /**
     * 
     * @type {CreateDiligenceBusinessInfo}
     * @memberof CreateDiligence
     */
    'business_info'?: CreateDiligenceBusinessInfo;
    /**
     * 
     * @type {CreateDiligenceReferenceExternalObjectType}
     * @memberof CreateDiligence
     */
    'reference_external_object_type'?: CreateDiligenceReferenceExternalObjectType | null;
    /**
     * Reference external object ID. Useful when needing to check the relationship between two objects.
     * @type {number}
     * @memberof CreateDiligence
     */
    'reference_external_object_id'?: number | null;
    /**
     * Other key values info for the diligence
     * @type {{ [key: string]: any; }}
     * @memberof CreateDiligence
     */
    'other_info'?: { [key: string]: any; } | null;
}
/**
 * @type CreateDiligenceBusinessInfo
 * Business information for diligence
 * @export
 */
export type CreateDiligenceBusinessInfo = BusinessInfo;

/**
 * @type CreateDiligenceDiligenceCategory
 * Category of the Diligence
 * @export
 */
export type CreateDiligenceDiligenceCategory = DiligenceCategory;

/**
 * @type CreateDiligenceDiligenceType
 * Type of diligence
 * @export
 */
export type CreateDiligenceDiligenceType = DiligenceType;

/**
 * @type CreateDiligenceExternalObjectType
 * External object type.
 * @export
 */
export type CreateDiligenceExternalObjectType = ObjectType;

/**
 * Reference external object type. Useful when the diligence is related to another object.
 * @export
 * @interface CreateDiligenceReferenceExternalObjectType
 */
export interface CreateDiligenceReferenceExternalObjectType {
}
/**
 * An entity with it\'s positions.
 * @export
 * @interface DetailedEntity
 */
export interface DetailedEntity {
    /**
     * 
     * @type {number}
     * @memberof DetailedEntity
     */
    'id'?: number;
    /**
     * Name of the entity.
     * @type {string}
     * @memberof DetailedEntity
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DetailedEntity
     */
    'arena_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DetailedEntity
     */
    'bank_account_id'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedEntity
     */
    'automated_payments_enabled'?: boolean;
    /**
     * 
     * @type {Array<Position>}
     * @memberof DetailedEntity
     */
    'positions'?: Array<Position>;
}
/**
 * Diligence used as a model for keeping track of investor diligence actions on a variety of items
 * @export
 * @interface Diligence
 */
export interface Diligence {
    /**
     * ID of the diligence object in the DB.
     * @type {number}
     * @memberof Diligence
     */
    'id': number;
    /**
     * 
     * @type {DiligenceExternalObjectType}
     * @memberof Diligence
     */
    'external_object_type': DiligenceExternalObjectType | null;
    /**
     * Number representing the id of the external object type in the external object type table.
     * @type {number}
     * @memberof Diligence
     */
    'external_object_id': number | null;
    /**
     * 
     * @type {DiligenceType}
     * @memberof Diligence
     */
    'diligence_type': DiligenceType;
    /**
     * 
     * @type {DiligenceStatus}
     * @memberof Diligence
     */
    'status': DiligenceStatus;
    /**
     * ID of user who reviewed the diligence
     * @type {number}
     * @memberof Diligence
     */
    'reviewer_user_id': number | null;
    /**
     * Date-time the diligence was moved into review status
     * @type {string}
     * @memberof Diligence
     */
    'review_start_date': string | null;
    /**
     * Date-time the diligence was moved out of review status
     * @type {string}
     * @memberof Diligence
     */
    'review_end_date': string | null;
    /**
     * ID of user who peer-reviewed the diligence
     * @type {number}
     * @memberof Diligence
     */
    'peer_reviewer_user_id': number | null;
    /**
     * Date-time the diligence was moved into peer-review status
     * @type {string}
     * @memberof Diligence
     */
    'peer_review_start_date': string | null;
    /**
     * Date-time the diligence was moved out of peer-review status
     * @type {string}
     * @memberof Diligence
     */
    'peer_review_end_date': string | null;
    /**
     * Arena ID the diligence is located in
     * @type {number}
     * @memberof Diligence
     */
    'arena_id': number;
    /**
     * Date-time the diligence was last modified
     * @type {string}
     * @memberof Diligence
     */
    'modified_at': string | null;
    /**
     * Date-time the diligence was created
     * @type {string}
     * @memberof Diligence
     */
    'created_at': string | null;
    /**
     * FK to the user id who created the diligence
     * @type {number}
     * @memberof Diligence
     */
    'created_by': number;
    /**
     * FK to the Investor Diligence Risk Log
     * @type {number}
     * @memberof Diligence
     */
    'current_investor_diligence_risk_log_id': number | null;
    /**
     * 
     * @type {DiligenceCategory}
     * @memberof Diligence
     */
    'category': DiligenceCategory;
    /**
     * String of external reference
     * @type {string}
     * @memberof Diligence
     */
    'external_reference_key': string | null;
    /**
     * Name of the diligence
     * @type {string}
     * @memberof Diligence
     */
    'name': string | null;
    /**
     * Only used for watchlist diligences. Used to determine if recurring checks is enabled
     * @type {boolean}
     * @memberof Diligence
     */
    'perform_recurring_check': boolean | null;
    /**
     * Other key values info for the diligence
     * @type {{ [key: string]: any; }}
     * @memberof Diligence
     */
    'other_info'?: { [key: string]: any; } | null;
}


/**
 * Category of Diligence
 * @export
 * @enum {string}
 */

export const DiligenceCategory = {
    PaymentsOnboardingFlow: 'payments_onboarding_flow'
} as const;

export type DiligenceCategory = typeof DiligenceCategory[keyof typeof DiligenceCategory];


/**
 * @type DiligenceExternalObjectType
 * External object type.
 * @export
 */
export type DiligenceExternalObjectType = ObjectType | object;

/**
 * Status of the diligence in the submission workflow
 * @export
 * @enum {string}
 */

export const DiligenceStatus = {
    Started: 'started',
    PendingReview: 'pending_review',
    RequestedLpForInfo: 'requested_lp_for_info',
    InReview: 'in_review',
    PendingPeerReview: 'pending_peer_review',
    InPeerReview: 'in_peer_review',
    Confirmed: 'confirmed'
} as const;

export type DiligenceStatus = typeof DiligenceStatus[keyof typeof DiligenceStatus];


/**
 * Type of Diligence. Differs from category because category represents what type of service/entity is requesting the diligence. DiligenceType represents the type of diligence created
 * @export
 * @enum {string}
 */

export const DiligenceType = {
    Kyc: 'kyc',
    WatchlistScreening: 'watchlist_screening',
    Manual: 'manual'
} as const;

export type DiligenceType = typeof DiligenceType[keyof typeof DiligenceType];


/**
 * A Distribution that is part of a distribution batch.
 * @export
 * @interface Distribution
 */
export interface Distribution {
    /**
     * 
     * @type {number}
     * @memberof Distribution
     */
    'id': number;
    /**
     * Arena ID this distribution batch belongs to.
     * @type {number}
     * @memberof Distribution
     */
    'arena_id': number;
    /**
     * FK to position ID this distribution belongs to
     * @type {number}
     * @memberof Distribution
     */
    'position_id': number;
    /**
     * FK to payment pref for this distribution\'s position\'s payment pref
     * @type {number}
     * @memberof Distribution
     */
    'payment_pref_id': number | null;
    /**
     * Amount to be distributed
     * @type {number}
     * @memberof Distribution
     */
    'amount': number;
    /**
     * Amount to be distributed netting any amount adjusted or reinvested
     * @type {number}
     * @memberof Distribution
     */
    'amount_payable': number;
    /**
     * The date the distribution was manually settled (if applicable)
     * @type {string}
     * @memberof Distribution
     */
    'manual_settlement_date': string | null;
    /**
     * Whether or not the distribution has a legacy payment associated with it (that has not been marked as canceled or failed or voided)
     * @type {boolean}
     * @memberof Distribution
     */
    'has_legacy_payment': boolean;
}
/**
 * A Distribution Batch.
 * @export
 * @interface DistributionBatch
 */
export interface DistributionBatch {
    /**
     * 
     * @type {number}
     * @memberof DistributionBatch
     */
    'id': number;
    /**
     * Total amount distributed
     * @type {number}
     * @memberof DistributionBatch
     */
    'total_amount': number;
    /**
     * Arena ID this distribution batch belongs to.
     * @type {number}
     * @memberof DistributionBatch
     */
    'arena_id': number;
    /**
     * Entity ID this distribution batch belongs to.
     * @type {number}
     * @memberof DistributionBatch
     */
    'entity_id': number;
}
/**
 * Documents for business
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * Document type
     * @type {string}
     * @memberof Document
     */
    'document_type'?: DocumentDocumentTypeEnum;
    /**
     * S3 Keys for documents
     * @type {string}
     * @memberof Document
     */
    's3_key'?: string;
    /**
     * Name of document
     * @type {string}
     * @memberof Document
     */
    'name'?: string;
    /**
     * Content type of document
     * @type {string}
     * @memberof Document
     */
    'content_type'?: DocumentContentTypeEnum;
}

export const DocumentDocumentTypeEnum = {
    IdentityDocument: 'identity_document',
    FormationDocument: 'formation_document',
    TaxDocument: 'tax_document',
    File: 'file',
    CorporateResolution: 'corporate_resolution',
    AuditedFinancial: 'audited_financial'
} as const;

export type DocumentDocumentTypeEnum = typeof DocumentDocumentTypeEnum[keyof typeof DocumentDocumentTypeEnum];
export const DocumentContentTypeEnum = {
    ImageWebp: 'image/webp',
    ApplicationPdf: 'application/pdf',
    ImagePng: 'image/png',
    ImageJpeg: 'image/jpeg'
} as const;

export type DocumentContentTypeEnum = typeof DocumentContentTypeEnum[keyof typeof DocumentContentTypeEnum];

/**
 * An entity
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    'arena_id': number;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    'bank_account_id'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    'automated_payments_enabled': boolean;
}
/**
 * A position for a specific arena, source name, and source object id.
 * @export
 * @interface ExternalPosition
 */
export interface ExternalPosition {
    /**
     * 
     * @type {number}
     * @memberof ExternalPosition
     */
    'id': number;
}
/**
 * Feature flags used to control application or arena wide availability of features. Note: presently only supports boolean (enabled/disabled) feature flags.
 * @export
 * @interface FeatureFlag
 */
export interface FeatureFlag {
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    'id': number;
    /**
     * The name of the feature flag.
     * @type {string}
     * @memberof FeatureFlag
     */
    'name': string;
    /**
     * A meaningful label for the feature flag.
     * @type {string}
     * @memberof FeatureFlag
     */
    'label': string;
    /**
     * A description of the purpose of the feature flag.
     * @type {string}
     * @memberof FeatureFlag
     */
    'description'?: string | null;
    /**
     * Whether the feature flag is enabled or disabled.
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'is_enabled': boolean;
    /**
     * Whether the feature flag has side-effect operations that must be performed when the feature flag is enabled or disabled.
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'has_side_effects'?: boolean;
}
/**
 * @type GetDeveloperFeatureFlags401Response
 * @export
 */
export type GetDeveloperFeatureFlags401Response = Array<ServerError> | ServerError;

/**
 * Granular permission enum
 * @export
 * @enum {string}
 */

export const GranularPermission = {
    ManagePortalSettings: 'CAN_MANAGE_PORTAL_SETTINGS',
    ManageGeneralSubscriptionSettings: 'CAN_MANAGE_GENERAL_SUBSCRIPTION_SETTINGS',
    ManageStaffAccess: 'CAN_MANAGE_STAFF_ACCESS',
    ManageSelf: 'CAN_MANAGE_SELF',
    ManageUserRoles: 'CAN_MANAGE_USER_ROLES',
    AssignAdministratorPermissionsToStaffUsers: 'CAN_ASSIGN_ADMINISTRATOR_PERMISSIONS_TO_STAFF_USERS',
    ManageAuthentication: 'CAN_MANAGE_AUTHENTICATION',
    ManageAgreements: 'CAN_MANAGE_AGREEMENTS',
    ManageDataFields: 'CAN_MANAGE_DATA_FIELDS',
    AccessAuditLog: 'CAN_ACCESS_AUDIT_LOG',
    ConfigDocumentCategories: 'CAN_CONFIG_DOCUMENT_CATEGORIES',
    ConfigEmailDistributionLists: 'CAN_CONFIG_EMAIL_DISTRIBUTION_LISTS',
    ConfigCrmNotificationLists: 'CAN_CONFIG_CRM_NOTIFICATION_LISTS',
    ConfigOwnershipUnitsAndPercentages: 'CAN_CONFIG_OWNERSHIP_UNITS_AND_PERCENTAGES',
    ConfigDistributionsAndCapitalTransactions: 'CAN_CONFIG_DISTRIBUTIONS_AND_CAPITAL_TRANSACTIONS',
    ConfigNetIncomeAndNavComponents: 'CAN_CONFIG_NET_INCOME_AND_NAV_COMPONENTS',
    ConfigEntitySubtypes: 'CAN_CONFIG_ENTITY_SUBTYPES',
    ConfigMetricsSettings: 'CAN_CONFIG_METRICS_SETTINGS',
    ConfigWatermarkTemplates: 'CAN_CONFIG_WATERMARK_TEMPLATES',
    ConfigManagementFees: 'CAN_CONFIG_MANAGEMENT_FEES',
    ConfigOrganizationSettings: 'CAN_CONFIG_ORGANIZATION_SETTINGS',
    ConfigESignatures: 'CAN_CONFIG_E_SIGNATURES',
    ConfigStatementNotices: 'CAN_CONFIG_STATEMENT_NOTICES',
    ConfigStationeryLibrary: 'CAN_CONFIG_STATIONERY_LIBRARY',
    ConfigReportingTemplate: 'CAN_CONFIG_REPORTING_TEMPLATE',
    ConfigIntegrations: 'CAN_CONFIG_INTEGRATIONS',
    ConfigMappings: 'CAN_CONFIG_MAPPINGS',
    AccessProspectSubscription: 'CAN_ACCESS_PROSPECT_SUBSCRIPTION'
} as const;

export type GranularPermission = typeof GranularPermission[keyof typeof GranularPermission];


/**
 * Individual profile for diligence
 * @export
 * @interface IndividualProfile
 */
export interface IndividualProfile {
    /**
     * Profile ID for diligence
     * @type {number}
     * @memberof IndividualProfile
     */
    'external_profile_id': number;
    /**
     * First name
     * @type {string}
     * @memberof IndividualProfile
     */
    'first_name': string;
    /**
     * Last name
     * @type {string}
     * @memberof IndividualProfile
     */
    'last_name': string;
    /**
     * Date of birth
     * @type {string}
     * @memberof IndividualProfile
     */
    'date_of_birth': string;
    /**
     * SSN
     * @type {string}
     * @memberof IndividualProfile
     */
    'tax_id': string;
    /**
     * 
     * @type {IndividualProfileAddress}
     * @memberof IndividualProfile
     */
    'address': IndividualProfileAddress;
    /**
     * Documents for individual
     * @type {Array<BusinessInfoDocumentsInner>}
     * @memberof IndividualProfile
     */
    'documents': Array<BusinessInfoDocumentsInner>;
    /**
     * Whether the individual is a beneficial owner
     * @type {boolean}
     * @memberof IndividualProfile
     */
    'is_beneficial_owner'?: boolean;
    /**
     * Whether the individual is a controller
     * @type {boolean}
     * @memberof IndividualProfile
     */
    'is_controller'?: boolean;
    /**
     * Whether the individual is a signatory
     * @type {boolean}
     * @memberof IndividualProfile
     */
    'is_signatory'?: boolean;
    /**
     * Potential percentage of the business the individual owns
     * @type {number}
     * @memberof IndividualProfile
     */
    'business_ownership_percent'?: number | null;
}
/**
 * @type IndividualProfileAddress
 * Address for individual
 * @export
 */
export type IndividualProfileAddress = Address;

/**
 * Institution profile for diligence
 * @export
 * @interface InstitutionProfile
 */
export interface InstitutionProfile {
    /**
     * Profile ID for institution
     * @type {number}
     * @memberof InstitutionProfile
     */
    'external_profile_id': number;
    /**
     * Name of institution
     * @type {string}
     * @memberof InstitutionProfile
     */
    'legal_entity_name': string;
    /**
     * Tax ID for institution
     * @type {string}
     * @memberof InstitutionProfile
     */
    'tax_id': string;
    /**
     * Date of formation for business
     * @type {string}
     * @memberof InstitutionProfile
     */
    'date_of_organization': string;
    /**
     * Whether the individual is a beneficial owner
     * @type {boolean}
     * @memberof InstitutionProfile
     */
    'is_beneficial_owner'?: boolean;
    /**
     * 
     * @type {InstitutionProfileAddress}
     * @memberof InstitutionProfile
     */
    'address': InstitutionProfileAddress;
    /**
     * Documents for individual
     * @type {Array<BusinessInfoDocumentsInner>}
     * @memberof InstitutionProfile
     */
    'documents': Array<BusinessInfoDocumentsInner>;
    /**
     * Potential percentage of the business the individual owns
     * @type {number}
     * @memberof InstitutionProfile
     */
    'business_ownership_percent'?: number | null;
}
/**
 * @type InstitutionProfileAddress
 * Address for institution
 * @export
 */
export type InstitutionProfileAddress = Address;

/**
 * Bulk account contact update and remove metadata
 * @export
 * @interface MetaData
 */
export interface MetaData {
    /**
     * Requester user ID
     * @type {number}
     * @memberof MetaData
     */
    'requester_user_id': number;
    /**
     * Comment for the bulk update from account admin
     * @type {string}
     * @memberof MetaData
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'exception'?: string;
}
/**
 * Returns the permissioning object for the queried user and object type combination.
 * @export
 * @interface ObjectLevelPermission
 */
export interface ObjectLevelPermission {
    /**
     * Boolean if the user has permission based on the specified filters
     * @type {boolean}
     * @memberof ObjectLevelPermission
     */
    'has_permission': boolean;
}
/**
 * String representation of ObjectType enum
 * @export
 * @enum {string}
 */

export const ObjectType = {
    Arena: 'arena',
    User: 'user',
    Contact: 'contact',
    Offering: 'offering',
    Prospect: 'prospect',
    Account: 'account',
    Property: 'property',
    CommPref: 'comm_pref',
    Position: 'position',
    Document: 'document',
    EmailBatch: 'email_batch',
    CapitalCallBatch: 'capital_call_batch',
    DistributionBatch: 'distribution_batch',
    Transaction: 'transaction',
    Asset: 'asset',
    ProspectContactMap: 'prospect_contact_map',
    DataRoom: 'data_room',
    NetIncomeBatch: 'net_income_batch',
    Publication: 'publication',
    SubscriptionBatch: 'subscription_batch',
    Subscription: 'subscription',
    EventLog: 'event_log',
    PaymentBatch: 'payment_batch',
    ManagementFeeBatch: 'management_fee_batch',
    Task: 'task',
    Lead: 'lead',
    CrmNotificationList: 'crm_notification_list',
    NavBatch: 'nav_batch',
    Loan: 'loan',
    AssetDateSampledData: 'asset_date_sampled_data',
    TransactionBatch: 'transaction_batch',
    UnitValue: 'unit_value',
    UnitValueBatch: 'unit_value_batch',
    CapitalCall: 'capital_call',
    Distribution: 'distribution',
    NetIncome: 'net_income',
    Nav: 'nav',
    Note: 'note',
    StoredEmail: 'stored_email',
    Email: 'email',
    InvestorDiligence: 'investor_diligence',
    WatchlistScreeningDetail: 'watchlist_screening_detail',
    KycDetail: 'kyc_detail',
    KycDocument: 'kyc_document',
    KycDocumentVersion: 'kyc_document_version',
    ImportTemplate: 'import_template',
    KycDocumentVersionActivity: 'kyc_document_version_activity',
    Acquisition: 'acquisition',
    Disposition: 'disposition',
    FeatureFlag: 'feature_flag',
    PaymentPref: 'payment_pref',
    DocumentCategory: 'document_category',
    ConsolidatedPaymentBatch: 'consolidated_payment_batch',
    ESignatureDocument: 'e_signature_document',
    ESignatureRequestTemplate: 'e_signature_request_template',
    ESignatureGpSigner: 'e_signature_gp_signer',
    ESignatureRequestBatch: 'e_signature_request_batch',
    ESignatureRequest: 'e_signature_request',
    ESignatureRequestRecipient: 'e_signature_request_recipient',
    ESignatureLpSigner: 'e_signature_lp_signer',
    ESignatureLpConfigurator: 'e_signature_lp_configurator',
    Payment: 'payment',
    BankAccount: 'bank_account',
    TwrPeriodMetric: 'twr_period_metric',
    FieldAccessRole: 'field_access_role',
    FieldAccessRoleObjectMap: 'field_access_role_object_map',
    Location: 'location',
    ProductType: 'product_type',
    DocumentFolder: 'document_folder',
    LpConsolidationRequest: 'lp_consolidation_request',
    FundAdminService: 'fund_admin_service',
    EntityCollection: 'entity_collection',
    ComplianceProfile: 'compliance_profile'
} as const;

export type ObjectType = typeof ObjectType[keyof typeof ObjectType];


/**
 * An entity\'s operating company information
 * @export
 * @interface Opco
 */
export interface Opco {
    /**
     * The Account ID of the operating company
     * @type {number}
     * @memberof Opco
     */
    'opco_id': number;
    /**
     * The name of the operating company
     * @type {string}
     * @memberof Opco
     */
    'opco_name': string;
    /**
     * The currency of the operating company
     * @type {string}
     * @memberof Opco
     */
    'opco_currency': string;
    /**
     * The positions associated with the operating company
     * @type {Array<OpcoPosition>}
     * @memberof Opco
     */
    'positions': Array<OpcoPosition>;
}
/**
 * An entity\'s position on its operating company
 * @export
 * @interface OpcoPosition
 */
export interface OpcoPosition {
    /**
     * 
     * @type {number}
     * @memberof OpcoPosition
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OpcoPosition
     */
    'investor_group_name': string;
    /**
     * 
     * @type {string}
     * @memberof OpcoPosition
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof OpcoPosition
     */
    'ownership_percent': string | null;
}
/**
 * A payment preference.
 * @export
 * @interface PaymentPref
 */
export interface PaymentPref {
    /**
     * 
     * @type {number}
     * @memberof PaymentPref
     */
    'id': number;
    /**
     * Payment method for the payment preference: ACH, Wire or Check.
     * @type {string}
     * @memberof PaymentPref
     */
    'payment_method': PaymentPrefPaymentMethodEnum;
    /**
     * Verification status for the payment preference: verified, unverified or error.
     * @type {string}
     * @memberof PaymentPref
     */
    'verification_status': PaymentPrefVerificationStatusEnum | null;
    /**
     * For wire payment method only, whether the wire payment pref has an intermediary bank that wires transfer through. 
     * @type {boolean}
     * @memberof PaymentPref
     */
    'wire_has_intermediary'?: boolean | null;
    /**
     * For wire payment method only, whether the wire payment pref has an international beneficiary address
     * @type {boolean}
     * @memberof PaymentPref
     */
    'wire_has_international_beneficiary_address'?: boolean | null;
    /**
     * 
     * @type {PaymentPrefPaymentPrefWire}
     * @memberof PaymentPref
     */
    'payment_pref_wire'?: PaymentPrefPaymentPrefWire | null;
    /**
     * 
     * @type {PaymentPrefPaymentPrefAch}
     * @memberof PaymentPref
     */
    'payment_pref_ach'?: PaymentPrefPaymentPrefAch | null;
}

export const PaymentPrefPaymentMethodEnum = {
    Ach: 'ACH',
    Check: 'Check',
    Wire: 'Wire'
} as const;

export type PaymentPrefPaymentMethodEnum = typeof PaymentPrefPaymentMethodEnum[keyof typeof PaymentPrefPaymentMethodEnum];
export const PaymentPrefVerificationStatusEnum = {
    Verified: 'verified',
    Unverified: 'unverified',
    Error: 'error'
} as const;

export type PaymentPrefVerificationStatusEnum = typeof PaymentPrefVerificationStatusEnum[keyof typeof PaymentPrefVerificationStatusEnum];

/**
 * A payment preference containing ach specific info. This will only have valid fields if payment pref method is ach. Otherwise, it will contain an empty object 
 * @export
 * @interface PaymentPrefPaymentPrefAch
 */
export interface PaymentPrefPaymentPrefAch {
    /**
     * Optional ach account name
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_account_name'?: string | null;
    /**
     * Ach bank name
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_bank_name': string;
    /**
     * ach account number
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_account_number': string;
    /**
     * ach routing number
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_routing_number': string;
    /**
     * ach account type
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_account_type': string;
    /**
     * ach account ownership
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_account_ownership'?: string | null;
    /**
     * ach account ownership
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_additional_instructions'?: string | null;
    /**
     * 
     * @type {PaymentPrefPaymentPrefAchAchDomicileAddress}
     * @memberof PaymentPrefPaymentPrefAch
     */
    'ach_domicile_address'?: PaymentPrefPaymentPrefAchAchDomicileAddress | null;
}
/**
 * 
 * @export
 * @interface PaymentPrefPaymentPrefAchAchDomicileAddress
 */
export interface PaymentPrefPaymentPrefAchAchDomicileAddress {
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'street1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'street2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'street3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'region'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'postal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefAchAchDomicileAddress
     */
    'country'?: string | null;
}
/**
 * A payment preference containing wire specific info. This will only have valid fields if payment pref method is wire. 
 * @export
 * @interface PaymentPrefPaymentPrefWire
 */
export interface PaymentPrefPaymentPrefWire {
    /**
     * Optional wire beneficiary name
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_beneficiary_name'?: string | null;
    /**
     * Wire beneficiary account number
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_beneficiary_account_number': string;
    /**
     * Wire bank name
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_bank_name': string;
    /**
     * Wire aba number (usually routing number)
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_aba_number': string;
    /**
     * For wire payment method only, whether the wire payment pref has an intermediary bank that wires transfer through. 
     * @type {boolean}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_has_intermediary': boolean;
    /**
     * Boolean to determine whether a wire has an international beneficiary address. Can be None if not applicable. 
     * @type {boolean}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_has_international_beneficiary_address'?: boolean | null;
    /**
     * Wire reference to beneficiary
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_reference_to_beneficiary'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_obi'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_bbi'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PaymentPrefPaymentPrefWireWireBeneficiaryAddress}
     * @memberof PaymentPrefPaymentPrefWire
     */
    'wire_beneficiary_address': PaymentPrefPaymentPrefWireWireBeneficiaryAddress;
}
/**
 * 
 * @export
 * @interface PaymentPrefPaymentPrefWireWireBeneficiaryAddress
 */
export interface PaymentPrefPaymentPrefWireWireBeneficiaryAddress {
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'street1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'street2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'street3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'region'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'postal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPrefPaymentPrefWireWireBeneficiaryAddress
     */
    'country'?: string | null;
}
/**
 * String representation of Permission enum
 * @export
 * @enum {string}
 */

export const Permission = {
    Create: 'create',
    Read: 'read',
    Update: 'update',
    Delete: 'delete',
    Administer: 'administer',
    Download: 'download',
    ManagePortal: 'manage_portal',
    LimitedRead: 'limited_read',
    PublishTransactions: 'publish_transactions',
    LimitedEdit: 'limited_edit'
} as const;

export type Permission = typeof Permission[keyof typeof Permission];


/**
 * A position in an investment entity.
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'id': number;
    /**
     * Name of the position.
     * @type {string}
     * @memberof Position
     */
    'name': string;
    /**
     * Amount that this position has committed to invest.
     * @type {number}
     * @memberof Position
     */
    'amount_committed': number | null;
    /**
     * Percentage of ownership in the investment.
     * @type {number}
     * @memberof Position
     */
    'percent_ownership': number | null;
    /**
     * Name of the position\'s investor group.
     * @type {string}
     * @memberof Position
     */
    'investor_group_name': string;
    /**
     * Capital account balances of position
     * @type {Array<PositionCabsInner>}
     * @memberof Position
     */
    'cabs': Array<PositionCabsInner> | null;
    /**
     * 
     * @type {Array<PositionContributionsInner>}
     * @memberof Position
     */
    'contributions'?: Array<PositionContributionsInner> | null;
    /**
     * 
     * @type {Array<PositionContributionsInner>}
     * @memberof Position
     */
    'distributions'?: Array<PositionContributionsInner> | null;
    /**
     * 
     * @type {Array<PositionNetIncomeSumByTypeInner>}
     * @memberof Position
     */
    'net_income_sum_by_type'?: Array<PositionNetIncomeSumByTypeInner> | null;
}
/**
 * A position with account, investor group, and investment entity ids.
 * @export
 * @interface PositionAttribute
 */
export interface PositionAttribute {
    /**
     * 
     * @type {number}
     * @memberof PositionAttribute
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PositionAttribute
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof PositionAttribute
     */
    'investment_entity_id': number;
    /**
     * 
     * @type {number}
     * @memberof PositionAttribute
     */
    'investor_group_id': number;
}
/**
 * 
 * @export
 * @interface PositionCabsInner
 */
export interface PositionCabsInner {
    /**
     * 
     * @type {string}
     * @memberof PositionCabsInner
     */
    'end': string;
    /**
     * 
     * @type {number}
     * @memberof PositionCabsInner
     */
    'balance': number;
}
/**
 * 
 * @export
 * @interface PositionContributionsInner
 */
export interface PositionContributionsInner {
    /**
     * 
     * @type {string}
     * @memberof PositionContributionsInner
     */
    'start_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof PositionContributionsInner
     */
    'end_date': string;
    /**
     * 
     * @type {number}
     * @memberof PositionContributionsInner
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface PositionNetIncomeSumByTypeInner
 */
export interface PositionNetIncomeSumByTypeInner {
    /**
     * 
     * @type {string}
     * @memberof PositionNetIncomeSumByTypeInner
     */
    'start_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof PositionNetIncomeSumByTypeInner
     */
    'end_date': string;
    /**
     * 
     * @type {number}
     * @memberof PositionNetIncomeSumByTypeInner
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof PositionNetIncomeSumByTypeInner
     */
    'type_id': number;
}
/**
 * Response status
 * @export
 * @enum {string}
 */

export const ResponseStatus = {
    Success: 'Success',
    Failure: 'Failure'
} as const;

export type ResponseStatus = typeof ResponseStatus[keyof typeof ResponseStatus];


/**
 * 
 * @export
 * @interface ServerError
 */
export interface ServerError {
    /**
     * 
     * @type {string}
     * @memberof ServerError
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ServerError
     */
    'exception'?: string;
}
/**
 * 
 * @export
 * @interface TransactionRollupStatus
 */
export interface TransactionRollupStatus {
    /**
     * The batch ID associated with the transaction rollup
     * @type {string}
     * @memberof TransactionRollupStatus
     */
    'sync_id'?: string;
    /**
     * The date and time the status was last updated
     * @type {string}
     * @memberof TransactionRollupStatus
     */
    'updated_at'?: string;
    /**
     * The current status of the transaction rollup
     * @type {string}
     * @memberof TransactionRollupStatus
     */
    'status'?: TransactionRollupStatusStatusEnum;
}

export const TransactionRollupStatusStatusEnum = {
    Received: 'received',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type TransactionRollupStatusStatusEnum = typeof TransactionRollupStatusStatusEnum[keyof typeof TransactionRollupStatusStatusEnum];

/**
 * Feature flags used to control application or arena wide availability of features. Note: presently only supports boolean (enabled/disabled) feature flags.
 * @export
 * @interface UpdateFeatureFlag
 */
export interface UpdateFeatureFlag {
    /**
     * Whether the feature flag is enabled or disabled.
     * @type {boolean}
     * @memberof UpdateFeatureFlag
     */
    'is_enabled': boolean;
}
/**
 * An object provided when updating (patch) payment prefs. Note: presently only supports verification_status.
 * @export
 * @interface UpdatePaymentPrefOptions
 */
export interface UpdatePaymentPrefOptions {
    /**
     * Verification status for the payment preference: verified, unverified or error.
     * @type {string}
     * @memberof UpdatePaymentPrefOptions
     */
    'verification_status'?: UpdatePaymentPrefOptionsVerificationStatusEnum | null;
}

export const UpdatePaymentPrefOptionsVerificationStatusEnum = {
    Verified: 'verified',
    Unverified: 'unverified',
    Error: 'error'
} as const;

export type UpdatePaymentPrefOptionsVerificationStatusEnum = typeof UpdatePaymentPrefOptionsVerificationStatusEnum[keyof typeof UpdatePaymentPrefOptionsVerificationStatusEnum];

/**
 * A User object.
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * Global ID for user.
     * @type {string}
     * @memberof User
     */
    'global_id': string;
    /**
     * User first name.
     * @type {string}
     * @memberof User
     */
    'first_name': string;
    /**
     * User last name.
     * @type {string}
     * @memberof User
     */
    'last_name': string;
    /**
     * User email.
     * @type {string}
     * @memberof User
     */
    'email_address': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API for account contact bulk removal
         * @summary API for account contact bulk removal
         * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkRemove: async (bulkAccountContactRemoveRequestBody?: BulkAccountContactRemoveRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-contact/bulk-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkAccountContactRemoveRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for account contact bulk update
         * @summary API for account contact bulk update
         * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkUpdate: async (bulkAccountContactUpdateRequestBody?: BulkAccountContactUpdateRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-contact/bulk-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkAccountContactUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for account contact change notification
         * @summary API for account contact change notification
         * @param {number} userId User ID of the resource
         * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactChangeNotify: async (userId: number, bulkAccountContactChangeNotify?: BulkAccountContactChangeNotify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountContactChangeNotify', 'userId', userId)
            const localVarPath = `/users/{user_id}/account-contact/bulk-notify`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkAccountContactChangeNotify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * API for account contact bulk removal
         * @summary API for account contact bulk removal
         * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountContactBulkRemove(bulkAccountContactRemoveRequestBody?: BulkAccountContactRemoveRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountContactBulkSuccessResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountContactBulkRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for account contact bulk update
         * @summary API for account contact bulk update
         * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountContactBulkUpdate(bulkAccountContactUpdateRequestBody?: BulkAccountContactUpdateRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountContactBulkSuccessResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountContactBulkUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for account contact change notification
         * @summary API for account contact change notification
         * @param {number} userId User ID of the resource
         * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountContactChangeNotify(userId: number, bulkAccountContactChangeNotify?: BulkAccountContactChangeNotify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountContactChangeNotify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * API for account contact bulk removal
         * @summary API for account contact bulk removal
         * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkRemove(bulkAccountContactRemoveRequestBody?: BulkAccountContactRemoveRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<Array<AccountContactBulkSuccessResponse>> {
            return localVarFp.accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * API for account contact bulk update
         * @summary API for account contact bulk update
         * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkUpdate(bulkAccountContactUpdateRequestBody?: BulkAccountContactUpdateRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<Array<AccountContactBulkSuccessResponse>> {
            return localVarFp.accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * API for account contact change notification
         * @summary API for account contact change notification
         * @param {number} userId User ID of the resource
         * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactChangeNotify(userId: number, bulkAccountContactChangeNotify?: BulkAccountContactChangeNotify, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * API for account contact bulk removal
     * @summary API for account contact bulk removal
     * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountContactBulkRemove(bulkAccountContactRemoveRequestBody?: BulkAccountContactRemoveRequestBody, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for account contact bulk update
     * @summary API for account contact bulk update
     * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountContactBulkUpdate(bulkAccountContactUpdateRequestBody?: BulkAccountContactUpdateRequestBody, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for account contact change notification
     * @summary API for account contact change notification
     * @param {number} userId User ID of the resource
     * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountContactChangeNotify(userId: number, bulkAccountContactChangeNotify?: BulkAccountContactChangeNotify, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArenasApi - axios parameter creator
 * @export
 */
export const ArenasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an un-paginated list of allocation types.
         * @summary Get a list of allocation types for the given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocationTypes: async (arenaId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getAllocationTypes', 'arenaId', arenaId)
            const localVarPath = `/arenas/{arena_id}/allocation_types`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an arena by ID.
         * @summary Get arena
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArena: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getArena', 'id', id)
            const localVarPath = `/arenas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get allocationTypes for a given arena by ID
         * @summary Get allocation types for a given arena by ID
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaNetIncomeTypes: async (arenaId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getArenaNetIncomeTypes', 'arenaId', arenaId)
            const localVarPath = `/arenas/{arena_id}/net_income_allocation_types`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment settings for a given arena by ID
         * @summary Get payment settings for a given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaPaymentSettings: async (arenaId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getArenaPaymentSettings', 'arenaId', arenaId)
            const localVarPath = `/arenas/{arena_id}/payment_settings`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
         * @summary Get a list of Arenas
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenas: async (ids?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/arenas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArenasApi - functional programming interface
 * @export
 */
export const ArenasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArenasApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an un-paginated list of allocation types.
         * @summary Get a list of allocation types for the given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllocationTypes(arenaId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllocationType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllocationTypes(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArenasApi.getAllocationTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an arena by ID.
         * @summary Get arena
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArena(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Arena>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArena(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArenasApi.getArena']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get allocationTypes for a given arena by ID
         * @summary Get allocation types for a given arena by ID
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaNetIncomeTypes(arenaId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArenaNetIncomeType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaNetIncomeTypes(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArenasApi.getArenaNetIncomeTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get payment settings for a given arena by ID
         * @summary Get payment settings for a given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaPaymentSettings(arenaId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArenaPaymentSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaPaymentSettings(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArenasApi.getArenaPaymentSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
         * @summary Get a list of Arenas
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenas(ids?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Arena>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenas(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArenasApi.getArenas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArenasApi - factory interface
 * @export
 */
export const ArenasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArenasApiFp(configuration)
    return {
        /**
         * Get an un-paginated list of allocation types.
         * @summary Get a list of allocation types for the given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocationTypes(arenaId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllocationType>> {
            return localVarFp.getAllocationTypes(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an arena by ID.
         * @summary Get arena
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArena(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Arena> {
            return localVarFp.getArena(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get allocationTypes for a given arena by ID
         * @summary Get allocation types for a given arena by ID
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaNetIncomeTypes(arenaId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ArenaNetIncomeType>> {
            return localVarFp.getArenaNetIncomeTypes(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment settings for a given arena by ID
         * @summary Get payment settings for a given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaPaymentSettings(arenaId: number, options?: RawAxiosRequestConfig): AxiosPromise<ArenaPaymentSettings> {
            return localVarFp.getArenaPaymentSettings(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
         * @summary Get a list of Arenas
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenas(ids?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Arena>> {
            return localVarFp.getArenas(ids, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArenasApi - object-oriented interface
 * @export
 * @class ArenasApi
 * @extends {BaseAPI}
 */
export class ArenasApi extends BaseAPI {
    /**
     * Get an un-paginated list of allocation types.
     * @summary Get a list of allocation types for the given arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    public getAllocationTypes(arenaId: number, options?: RawAxiosRequestConfig) {
        return ArenasApiFp(this.configuration).getAllocationTypes(arenaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an arena by ID.
     * @summary Get arena
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    public getArena(id: number, options?: RawAxiosRequestConfig) {
        return ArenasApiFp(this.configuration).getArena(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get allocationTypes for a given arena by ID
     * @summary Get allocation types for a given arena by ID
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    public getArenaNetIncomeTypes(arenaId: number, options?: RawAxiosRequestConfig) {
        return ArenasApiFp(this.configuration).getArenaNetIncomeTypes(arenaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payment settings for a given arena by ID
     * @summary Get payment settings for a given arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    public getArenaPaymentSettings(arenaId: number, options?: RawAxiosRequestConfig) {
        return ArenasApiFp(this.configuration).getArenaPaymentSettings(arenaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
     * @summary Get a list of Arenas
     * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    public getArenas(ids?: Array<number>, options?: RawAxiosRequestConfig) {
        return ArenasApiFp(this.configuration).getArenas(ids, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankAccountApi - axios parameter creator
 * @export
 */
export const BankAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the name of the provided bank_account_id
         * @summary Get a bank account (BankAccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankAccount: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBankAccount', 'id', id)
            const localVarPath = `/bank_account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankAccountApi - functional programming interface
 * @export
 */
export const BankAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the name of the provided bank_account_id
         * @summary Get a bank account (BankAccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankAccount(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankAccount(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountApi.getBankAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankAccountApi - factory interface
 * @export
 */
export const BankAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankAccountApiFp(configuration)
    return {
        /**
         * Get the name of the provided bank_account_id
         * @summary Get a bank account (BankAccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankAccount(id: number, options?: RawAxiosRequestConfig): AxiosPromise<BankAccount> {
            return localVarFp.getBankAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankAccountApi - object-oriented interface
 * @export
 * @class BankAccountApi
 * @extends {BaseAPI}
 */
export class BankAccountApi extends BaseAPI {
    /**
     * Get the name of the provided bank_account_id
     * @summary Get a bank account (BankAccountModel)
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountApi
     */
    public getBankAccount(id: number, options?: RawAxiosRequestConfig) {
        return BankAccountApiFp(this.configuration).getBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DiligencesApi - axios parameter creator
 * @export
 */
export const DiligencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
         * @summary Create a diligence object and underlying KYC/watchlists
         * @param {CreateDiligence} [createDiligence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiligences: async (createDiligence?: CreateDiligence, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/diligences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDiligence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of diligences
         * @summary Get a list of diligences
         * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
         * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
         * @param {number} [objectId] Object ID to filter on
         * @param {Array<number>} [objectIds] Object IDs to filter on
         * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
         * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiligences: async (diligenceCategory: DiligenceCategory, objectType?: ObjectType, objectId?: number, objectIds?: Array<number>, diligenceType?: DiligenceType, diligenceStatus?: DiligenceStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'diligenceCategory' is not null or undefined
            assertParamExists('getDiligences', 'diligenceCategory', diligenceCategory)
            const localVarPath = `/diligences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (diligenceCategory !== undefined) {
                localVarQueryParameter['diligence_category'] = diligenceCategory;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (objectIds) {
                localVarQueryParameter['object_ids'] = objectIds.join(COLLECTION_FORMATS.csv);
            }

            if (diligenceType !== undefined) {
                localVarQueryParameter['diligence_type'] = diligenceType;
            }

            if (diligenceStatus !== undefined) {
                localVarQueryParameter['diligence_status'] = diligenceStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiligencesApi - functional programming interface
 * @export
 */
export const DiligencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiligencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
         * @summary Create a diligence object and underlying KYC/watchlists
         * @param {CreateDiligence} [createDiligence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiligences(createDiligence?: CreateDiligence, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Diligence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiligences(createDiligence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiligencesApi.createDiligences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of diligences
         * @summary Get a list of diligences
         * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
         * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
         * @param {number} [objectId] Object ID to filter on
         * @param {Array<number>} [objectIds] Object IDs to filter on
         * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
         * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiligences(diligenceCategory: DiligenceCategory, objectType?: ObjectType, objectId?: number, objectIds?: Array<number>, diligenceType?: DiligenceType, diligenceStatus?: DiligenceStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Diligence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiligencesApi.getDiligences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DiligencesApi - factory interface
 * @export
 */
export const DiligencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiligencesApiFp(configuration)
    return {
        /**
         * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
         * @summary Create a diligence object and underlying KYC/watchlists
         * @param {CreateDiligence} [createDiligence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiligences(createDiligence?: CreateDiligence, options?: RawAxiosRequestConfig): AxiosPromise<Diligence> {
            return localVarFp.createDiligences(createDiligence, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of diligences
         * @summary Get a list of diligences
         * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
         * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
         * @param {number} [objectId] Object ID to filter on
         * @param {Array<number>} [objectIds] Object IDs to filter on
         * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
         * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiligences(diligenceCategory: DiligenceCategory, objectType?: ObjectType, objectId?: number, objectIds?: Array<number>, diligenceType?: DiligenceType, diligenceStatus?: DiligenceStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<Diligence>> {
            return localVarFp.getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiligencesApi - object-oriented interface
 * @export
 * @class DiligencesApi
 * @extends {BaseAPI}
 */
export class DiligencesApi extends BaseAPI {
    /**
     * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
     * @summary Create a diligence object and underlying KYC/watchlists
     * @param {CreateDiligence} [createDiligence] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiligencesApi
     */
    public createDiligences(createDiligence?: CreateDiligence, options?: RawAxiosRequestConfig) {
        return DiligencesApiFp(this.configuration).createDiligences(createDiligence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an un-paginated list of diligences
     * @summary Get a list of diligences
     * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
     * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
     * @param {number} [objectId] Object ID to filter on
     * @param {Array<number>} [objectIds] Object IDs to filter on
     * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
     * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiligencesApi
     */
    public getDiligences(diligenceCategory: DiligenceCategory, objectType?: ObjectType, objectId?: number, objectIds?: Array<number>, diligenceType?: DiligenceType, diligenceStatus?: DiligenceStatus, options?: RawAxiosRequestConfig) {
        return DiligencesApiFp(this.configuration).getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DistributionApi - axios parameter creator
 * @export
 */
export const DistributionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a distribution by the given distribution id. This does not handle auth.
         * @summary Get distribution
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistribution: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistribution', 'id', id)
            const localVarPath = `/distributions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistributionApi - functional programming interface
 * @export
 */
export const DistributionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DistributionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a distribution by the given distribution id. This does not handle auth.
         * @summary Get distribution
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistribution(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Distribution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistribution(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DistributionApi.getDistribution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DistributionApi - factory interface
 * @export
 */
export const DistributionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DistributionApiFp(configuration)
    return {
        /**
         * Get a distribution by the given distribution id. This does not handle auth.
         * @summary Get distribution
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistribution(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Distribution> {
            return localVarFp.getDistribution(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistributionApi - object-oriented interface
 * @export
 * @class DistributionApi
 * @extends {BaseAPI}
 */
export class DistributionApi extends BaseAPI {
    /**
     * Get a distribution by the given distribution id. This does not handle auth.
     * @summary Get distribution
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public getDistribution(id: number, options?: RawAxiosRequestConfig) {
        return DistributionApiFp(this.configuration).getDistribution(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DistributionBatchesApi - axios parameter creator
 * @export
 */
export const DistributionBatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a distribution batch by ID. This does not handle auth checks.
         * @summary Get distribution batch no authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionBatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistributionBatch', 'id', id)
            const localVarPath = `/distribution_batches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
         * @summary Get distributions for a distribution batch not authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionsForDistributionBatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistributionsForDistributionBatch', 'id', id)
            const localVarPath = `/distribution_batches/{id}/distributions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistributionBatchesApi - functional programming interface
 * @export
 */
export const DistributionBatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DistributionBatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a distribution batch by ID. This does not handle auth checks.
         * @summary Get distribution batch no authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistributionBatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistributionBatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistributionBatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DistributionBatchesApi.getDistributionBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
         * @summary Get distributions for a distribution batch not authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistributionsForDistributionBatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Distribution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistributionsForDistributionBatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DistributionBatchesApi.getDistributionsForDistributionBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DistributionBatchesApi - factory interface
 * @export
 */
export const DistributionBatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DistributionBatchesApiFp(configuration)
    return {
        /**
         * Get a distribution batch by ID. This does not handle auth checks.
         * @summary Get distribution batch no authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionBatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DistributionBatch> {
            return localVarFp.getDistributionBatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
         * @summary Get distributions for a distribution batch not authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionsForDistributionBatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Distribution>> {
            return localVarFp.getDistributionsForDistributionBatch(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistributionBatchesApi - object-oriented interface
 * @export
 * @class DistributionBatchesApi
 * @extends {BaseAPI}
 */
export class DistributionBatchesApi extends BaseAPI {
    /**
     * Get a distribution batch by ID. This does not handle auth checks.
     * @summary Get distribution batch no authorization checks
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionBatchesApi
     */
    public getDistributionBatch(id: number, options?: RawAxiosRequestConfig) {
        return DistributionBatchesApiFp(this.configuration).getDistributionBatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
     * @summary Get distributions for a distribution batch not authorization checks
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionBatchesApi
     */
    public getDistributionsForDistributionBatch(id: number, options?: RawAxiosRequestConfig) {
        return DistributionBatchesApiFp(this.configuration).getDistributionsForDistributionBatch(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntitiesApi - axios parameter creator
 * @export
 */
export const EntitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an un-paginated list of investment entities with their positions.
         * @summary Get a list of investment entities with their positions in an arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [entityIds] Comma separated list of entity ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithPositions: async (arenaId: number, entityIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getEntitiesWithPositions', 'arenaId', arenaId)
            const localVarPath = `/arenas/{arena_id}/entities`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entityIds) {
                localVarQueryParameter['entity_ids'] = entityIds.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the name of the provided entity_id
         * @summary Get an entity (AccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntity', 'id', id)
            const localVarPath = `/entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of entity ids filtered by query params
         * @summary Get entity ids
         * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityIds: async (isFundAdmin?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entity-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isFundAdmin !== undefined) {
                localVarQueryParameter['is_fund_admin'] = isFundAdmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of positions in an investment entity.
         * @summary Get a list of positions in an investment entity.
         * @param {number} id Id of the resource
         * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityPositions: async (id: number, cabPeriodEnds?: Array<string>, transactionDates?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntityPositions', 'id', id)
            const localVarPath = `/entities/{id}/positions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cabPeriodEnds) {
                localVarQueryParameter['cab_period_ends'] = cabPeriodEnds.join(COLLECTION_FORMATS.csv);
            }

            if (transactionDates) {
                localVarQueryParameter['transaction_dates'] = transactionDates.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an un-paginated list of investment entities with their positions.
         * @summary Get a list of investment entities with their positions in an arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [entityIds] Comma separated list of entity ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitiesWithPositions(arenaId: number, entityIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailedEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitiesWithPositions(arenaId, entityIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.getEntitiesWithPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the name of the provided entity_id
         * @summary Get an entity (AccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntity(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.getEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of entity ids filtered by query params
         * @summary Get entity ids
         * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityIds(isFundAdmin?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityIds(isFundAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.getEntityIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of positions in an investment entity.
         * @summary Get a list of positions in an investment entity.
         * @param {number} id Id of the resource
         * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityPositions(id: number, cabPeriodEnds?: Array<string>, transactionDates?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityPositions(id, cabPeriodEnds, transactionDates, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.getEntityPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitiesApiFp(configuration)
    return {
        /**
         * Get an un-paginated list of investment entities with their positions.
         * @summary Get a list of investment entities with their positions in an arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [entityIds] Comma separated list of entity ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithPositions(arenaId: number, entityIds?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<DetailedEntity>> {
            return localVarFp.getEntitiesWithPositions(arenaId, entityIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the name of the provided entity_id
         * @summary Get an entity (AccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Entity> {
            return localVarFp.getEntity(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of entity ids filtered by query params
         * @summary Get entity ids
         * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityIds(isFundAdmin?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getEntityIds(isFundAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of positions in an investment entity.
         * @summary Get a list of positions in an investment entity.
         * @param {number} id Id of the resource
         * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityPositions(id: number, cabPeriodEnds?: Array<string>, transactionDates?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Position>> {
            return localVarFp.getEntityPositions(id, cabPeriodEnds, transactionDates, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI {
    /**
     * Get an un-paginated list of investment entities with their positions.
     * @summary Get a list of investment entities with their positions in an arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {Array<string>} [entityIds] Comma separated list of entity ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntitiesWithPositions(arenaId: number, entityIds?: Array<string>, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).getEntitiesWithPositions(arenaId, entityIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the name of the provided entity_id
     * @summary Get an entity (AccountModel)
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntity(id: number, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).getEntity(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an un-paginated list of entity ids filtered by query params
     * @summary Get entity ids
     * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityIds(isFundAdmin?: boolean, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).getEntityIds(isFundAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an un-paginated list of positions in an investment entity.
     * @summary Get a list of positions in an investment entity.
     * @param {number} id Id of the resource
     * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
     * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityPositions(id: number, cabPeriodEnds?: Array<string>, transactionDates?: Array<string>, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).getEntityPositions(id, cabPeriodEnds, transactionDates, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeatureFlagsApi - axios parameter creator
 * @export
 */
export const FeatureFlagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk update the state of arena feature flags.
         * @summary Bulk Update Arena Feature Flags
         * @param {number} arenaId Id of the arena to operate within
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateArenaFeatureFlags: async (arenaId: number, bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('bulkUpdateArenaFeatureFlags', 'arenaId', arenaId)
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrf-token required
            await setApiKeyToObject(localVarHeaderParameter, "X-CSRF-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUpdateFeatureFlags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk update the state of developer feature flags.
         * @summary Bulk Update Developer Feature Flags
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateDeveloperFeatureFlags: async (bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feature-flags/developer-feature-flags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrf-token required
            await setApiKeyToObject(localVarHeaderParameter, "X-CSRF-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUpdateFeatureFlags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an arena feature flag by feature flag name and arena domain
         * @summary Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlag: async (arenaId: number, featureFlagName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getArenaFeatureFlag', 'arenaId', arenaId)
            // verify required parameter 'featureFlagName' is not null or undefined
            assertParamExists('getArenaFeatureFlag', 'featureFlagName', featureFlagName)
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/{feature_flag_name}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all arena-level feature flags for an arena.
         * @summary Feature Flags for Arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlags: async (arenaId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getArenaFeatureFlags', 'arenaId', arenaId)
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a developer feature flag by name.
         * @summary Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlag: async (featureFlagName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureFlagName' is not null or undefined
            assertParamExists('getDeveloperFeatureFlag', 'featureFlagName', featureFlagName)
            const localVarPath = `/feature-flags/developer-feature-flags/{feature_flag_name}/`
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all developer feature flags.
         * @summary Developer Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feature-flags/developer-feature-flags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a developer feature flag
         * @summary Update Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArenaFeatureFlag: async (arenaId: number, featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('updateArenaFeatureFlag', 'arenaId', arenaId)
            // verify required parameter 'featureFlagName' is not null or undefined
            assertParamExists('updateArenaFeatureFlag', 'featureFlagName', featureFlagName)
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/{feature_flag_name}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureFlag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a developer feature flag
         * @summary Update Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeveloperFeatureFlag: async (featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureFlagName' is not null or undefined
            assertParamExists('updateDeveloperFeatureFlag', 'featureFlagName', featureFlagName)
            const localVarPath = `/feature-flags/developer-feature-flags/{feature_flag_name}/`
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureFlag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureFlagsApi - functional programming interface
 * @export
 */
export const FeatureFlagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureFlagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk update the state of arena feature flags.
         * @summary Bulk Update Arena Feature Flags
         * @param {number} arenaId Id of the arena to operate within
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateArenaFeatureFlags(arenaId: number, bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.bulkUpdateArenaFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk update the state of developer feature flags.
         * @summary Bulk Update Developer Feature Flags
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.bulkUpdateDeveloperFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves an arena feature flag by feature flag name and arena domain
         * @summary Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaFeatureFlag(arenaId: number, featureFlagName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaFeatureFlag(arenaId, featureFlagName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.getArenaFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all arena-level feature flags for an arena.
         * @summary Feature Flags for Arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaFeatureFlags(arenaId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureFlag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaFeatureFlags(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.getArenaFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a developer feature flag by name.
         * @summary Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperFeatureFlag(featureFlagName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperFeatureFlag(featureFlagName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.getDeveloperFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all developer feature flags.
         * @summary Developer Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperFeatureFlags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureFlag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperFeatureFlags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.getDeveloperFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a developer feature flag
         * @summary Update Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArenaFeatureFlag(arenaId: number, featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.updateArenaFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a developer feature flag
         * @summary Update Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeveloperFeatureFlag(featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.updateDeveloperFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeatureFlagsApi - factory interface
 * @export
 */
export const FeatureFlagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureFlagsApiFp(configuration)
    return {
        /**
         * Bulk update the state of arena feature flags.
         * @summary Bulk Update Arena Feature Flags
         * @param {number} arenaId Id of the arena to operate within
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateArenaFeatureFlags(arenaId: number, bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk update the state of developer feature flags.
         * @summary Bulk Update Developer Feature Flags
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an arena feature flag by feature flag name and arena domain
         * @summary Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlag(arenaId: number, featureFlagName: string, options?: RawAxiosRequestConfig): AxiosPromise<FeatureFlag> {
            return localVarFp.getArenaFeatureFlag(arenaId, featureFlagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all arena-level feature flags for an arena.
         * @summary Feature Flags for Arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlags(arenaId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FeatureFlag>> {
            return localVarFp.getArenaFeatureFlags(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a developer feature flag by name.
         * @summary Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlag(featureFlagName: string, options?: RawAxiosRequestConfig): AxiosPromise<FeatureFlag> {
            return localVarFp.getDeveloperFeatureFlag(featureFlagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all developer feature flags.
         * @summary Developer Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlags(options?: RawAxiosRequestConfig): AxiosPromise<Array<FeatureFlag>> {
            return localVarFp.getDeveloperFeatureFlags(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a developer feature flag
         * @summary Update Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArenaFeatureFlag(arenaId: number, featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options?: RawAxiosRequestConfig): AxiosPromise<FeatureFlag> {
            return localVarFp.updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a developer feature flag
         * @summary Update Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeveloperFeatureFlag(featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options?: RawAxiosRequestConfig): AxiosPromise<FeatureFlag> {
            return localVarFp.updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureFlagsApi - object-oriented interface
 * @export
 * @class FeatureFlagsApi
 * @extends {BaseAPI}
 */
export class FeatureFlagsApi extends BaseAPI {
    /**
     * Bulk update the state of arena feature flags.
     * @summary Bulk Update Arena Feature Flags
     * @param {number} arenaId Id of the arena to operate within
     * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public bulkUpdateArenaFeatureFlags(arenaId: number, bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk update the state of developer feature flags.
     * @summary Bulk Update Developer Feature Flags
     * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags?: BulkUpdateFeatureFlags, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an arena feature flag by feature flag name and arena domain
     * @summary Arena Feature Flag
     * @param {number} arenaId Id of the arena to operate within
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getArenaFeatureFlag(arenaId: number, featureFlagName: string, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getArenaFeatureFlag(arenaId, featureFlagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all arena-level feature flags for an arena.
     * @summary Feature Flags for Arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getArenaFeatureFlags(arenaId: number, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getArenaFeatureFlags(arenaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a developer feature flag by name.
     * @summary Developer Feature Flag
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getDeveloperFeatureFlag(featureFlagName: string, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getDeveloperFeatureFlag(featureFlagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all developer feature flags.
     * @summary Developer Feature Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getDeveloperFeatureFlags(options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getDeveloperFeatureFlags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a developer feature flag
     * @summary Update Arena Feature Flag
     * @param {number} arenaId Id of the arena to operate within
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public updateArenaFeatureFlag(arenaId: number, featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a developer feature flag
     * @summary Update Developer Feature Flag
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public updateDeveloperFeatureFlag(featureFlagName: string, updateFeatureFlag?: UpdateFeatureFlag, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentPrefsApi - axios parameter creator
 * @export
 */
export const PaymentPrefsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
         * @summary Get a list of payment prefs
         * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPrefs: async (ids: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getPaymentPrefs', 'ids', ids)
            const localVarPath = `/payment_prefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
         * @summary Update payment pref
         * @param {number} id Id of the resource
         * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentPref: async (id: number, updatePaymentPrefOptions?: UpdatePaymentPrefOptions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePaymentPref', 'id', id)
            const localVarPath = `/payment_prefs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentPrefOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentPrefsApi - functional programming interface
 * @export
 */
export const PaymentPrefsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentPrefsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
         * @summary Get a list of payment prefs
         * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentPrefs(ids: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentPref>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentPrefs(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPrefsApi.getPaymentPrefs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
         * @summary Update payment pref
         * @param {number} id Id of the resource
         * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentPref(id: number, updatePaymentPrefOptions?: UpdatePaymentPrefOptions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentPref>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentPref(id, updatePaymentPrefOptions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPrefsApi.updatePaymentPref']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentPrefsApi - factory interface
 * @export
 */
export const PaymentPrefsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentPrefsApiFp(configuration)
    return {
        /**
         * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
         * @summary Get a list of payment prefs
         * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPrefs(ids: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<PaymentPref>> {
            return localVarFp.getPaymentPrefs(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
         * @summary Update payment pref
         * @param {number} id Id of the resource
         * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentPref(id: number, updatePaymentPrefOptions?: UpdatePaymentPrefOptions, options?: RawAxiosRequestConfig): AxiosPromise<PaymentPref> {
            return localVarFp.updatePaymentPref(id, updatePaymentPrefOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentPrefsApi - object-oriented interface
 * @export
 * @class PaymentPrefsApi
 * @extends {BaseAPI}
 */
export class PaymentPrefsApi extends BaseAPI {
    /**
     * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
     * @summary Get a list of payment prefs
     * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentPrefsApi
     */
    public getPaymentPrefs(ids: Array<number>, options?: RawAxiosRequestConfig) {
        return PaymentPrefsApiFp(this.configuration).getPaymentPrefs(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
     * @summary Update payment pref
     * @param {number} id Id of the resource
     * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentPrefsApi
     */
    public updatePaymentPref(id: number, updatePaymentPrefOptions?: UpdatePaymentPrefOptions, options?: RawAxiosRequestConfig) {
        return PaymentPrefsApiFp(this.configuration).updatePaymentPref(id, updatePaymentPrefOptions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of granular permissions given user has.
         * @summary Returns a list of granular permissions given user has.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGranularPermissions: async (arenaId: number, userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getGranularPermissions', 'arenaId', arenaId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getGranularPermissions', 'userId', userId)
            const localVarPath = `/arenas/{arena_id}/users/{user_id}/granular_permissions`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @param {number} userId Required user_id to filter by.
         * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
         * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
         * @param {Array<Permission>} permissions List of object level permissions to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectLevelPermissions: async (userId: number, objectType: ObjectType, objectIds: Array<number>, permissions: Array<Permission>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getObjectLevelPermissions', 'userId', userId)
            // verify required parameter 'objectType' is not null or undefined
            assertParamExists('getObjectLevelPermissions', 'objectType', objectType)
            // verify required parameter 'objectIds' is not null or undefined
            assertParamExists('getObjectLevelPermissions', 'objectIds', objectIds)
            // verify required parameter 'permissions' is not null or undefined
            assertParamExists('getObjectLevelPermissions', 'permissions', permissions)
            const localVarPath = `/object_level_permission`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (objectIds) {
                localVarQueryParameter['object_ids'] = objectIds.join(COLLECTION_FORMATS.csv);
            }

            if (permissions) {
                localVarQueryParameter['permissions'] = permissions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of granular permissions given user has.
         * @summary Returns a list of granular permissions given user has.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGranularPermissions(arenaId: number, userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GranularPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGranularPermissions(arenaId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getGranularPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @param {number} userId Required user_id to filter by.
         * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
         * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
         * @param {Array<Permission>} permissions List of object level permissions to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectLevelPermissions(userId: number, objectType: ObjectType, objectIds: Array<number>, permissions: Array<Permission>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectLevelPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectLevelPermissions(userId, objectType, objectIds, permissions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getObjectLevelPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * Returns a list of granular permissions given user has.
         * @summary Returns a list of granular permissions given user has.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGranularPermissions(arenaId: number, userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GranularPermission>> {
            return localVarFp.getGranularPermissions(arenaId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @param {number} userId Required user_id to filter by.
         * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
         * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
         * @param {Array<Permission>} permissions List of object level permissions to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectLevelPermissions(userId: number, objectType: ObjectType, objectIds: Array<number>, permissions: Array<Permission>, options?: RawAxiosRequestConfig): AxiosPromise<ObjectLevelPermission> {
            return localVarFp.getObjectLevelPermissions(userId, objectType, objectIds, permissions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * Returns a list of granular permissions given user has.
     * @summary Returns a list of granular permissions given user has.
     * @param {number} arenaId Id of the arena to operate within
     * @param {number} userId User ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getGranularPermissions(arenaId: number, userId: number, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getGranularPermissions(arenaId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
     * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
     * @param {number} userId Required user_id to filter by.
     * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
     * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
     * @param {Array<Permission>} permissions List of object level permissions to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getObjectLevelPermissions(userId: number, objectType: ObjectType, objectIds: Array<number>, permissions: Array<Permission>, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getObjectLevelPermissions(userId, objectType, objectIds, permissions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PositionsApi - axios parameter creator
 * @export
 */
export const PositionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets position of a specific arena and source
         * @summary Gets position of a specific arena and source
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalPosition: async (arenaId: number, externalPositionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getExternalPosition', 'arenaId', arenaId)
            // verify required parameter 'externalPositionId' is not null or undefined
            assertParamExists('getExternalPosition', 'externalPositionId', externalPositionId)
            const localVarPath = `/arenas/{arena_id}/external_positions/{external_position_id}`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"external_position_id"}}`, encodeURIComponent(String(externalPositionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
         * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} entityId Id of the entity
         * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
         * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpcoPositions: async (arenaId: number, entityId: number, excludeInactive?: boolean, asOfDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getOpcoPositions', 'arenaId', arenaId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getOpcoPositions', 'entityId', entityId)
            const localVarPath = `/arenas/{arena_id}/entities/{entity_id}/opco_positions`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (excludeInactive !== undefined) {
                localVarQueryParameter['exclude_inactive'] = excludeInactive;
            }

            if (asOfDate !== undefined) {
                localVarQueryParameter['as_of_date'] = asOfDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions by ids with account, investor group, and investment entity ids.
         * @summary Gets positions by ids with account, investor group, and investment entity ids.
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [positionIds] Comma separated list of position ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionsAttributes: async (arenaId: number, positionIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arenaId' is not null or undefined
            assertParamExists('getPositionsAttributes', 'arenaId', arenaId)
            const localVarPath = `/arenas/{arena_id}/positions_attributes`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (positionIds) {
                localVarQueryParameter['position_ids'] = positionIds.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PositionsApi - functional programming interface
 * @export
 */
export const PositionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PositionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets position of a specific arena and source
         * @summary Gets position of a specific arena and source
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalPosition(arenaId: number, externalPositionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalPosition(arenaId, externalPositionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionsApi.getExternalPosition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
         * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} entityId Id of the entity
         * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
         * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpcoPositions(arenaId: number, entityId: number, excludeInactive?: boolean, asOfDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Opco>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionsApi.getOpcoPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets positions by ids with account, investor group, and investment entity ids.
         * @summary Gets positions by ids with account, investor group, and investment entity ids.
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [positionIds] Comma separated list of position ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionsAttributes(arenaId: number, positionIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionsAttributes(arenaId, positionIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionsApi.getPositionsAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PositionsApi - factory interface
 * @export
 */
export const PositionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PositionsApiFp(configuration)
    return {
        /**
         * Gets position of a specific arena and source
         * @summary Gets position of a specific arena and source
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalPosition(arenaId: number, externalPositionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExternalPosition> {
            return localVarFp.getExternalPosition(arenaId, externalPositionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
         * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} entityId Id of the entity
         * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
         * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpcoPositions(arenaId: number, entityId: number, excludeInactive?: boolean, asOfDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Opco>> {
            return localVarFp.getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets positions by ids with account, investor group, and investment entity ids.
         * @summary Gets positions by ids with account, investor group, and investment entity ids.
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [positionIds] Comma separated list of position ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionsAttributes(arenaId: number, positionIds?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<PositionAttribute>> {
            return localVarFp.getPositionsAttributes(arenaId, positionIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PositionsApi - object-oriented interface
 * @export
 * @class PositionsApi
 * @extends {BaseAPI}
 */
export class PositionsApi extends BaseAPI {
    /**
     * Gets position of a specific arena and source
     * @summary Gets position of a specific arena and source
     * @param {number} arenaId Id of the arena to operate within
     * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public getExternalPosition(arenaId: number, externalPositionId: string, options?: RawAxiosRequestConfig) {
        return PositionsApiFp(this.configuration).getExternalPosition(arenaId, externalPositionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
     * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
     * @param {number} arenaId Id of the arena to operate within
     * @param {number} entityId Id of the entity
     * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
     * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public getOpcoPositions(arenaId: number, entityId: number, excludeInactive?: boolean, asOfDate?: string, options?: RawAxiosRequestConfig) {
        return PositionsApiFp(this.configuration).getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets positions by ids with account, investor group, and investment entity ids.
     * @summary Gets positions by ids with account, investor group, and investment entity ids.
     * @param {number} arenaId Id of the arena to operate within
     * @param {Array<string>} [positionIds] Comma separated list of position ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public getPositionsAttributes(arenaId: number, positionIds?: Array<string>, options?: RawAxiosRequestConfig) {
        return PositionsApiFp(this.configuration).getPositionsAttributes(arenaId, positionIds, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the transaction rollup status for a specified batch ID.
         * @summary Retrieve a single transaction rollup status by batch ID
         * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatus: async (syncId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncId' is not null or undefined
            assertParamExists('getTransactionRollupStatus', 'syncId', syncId)
            const localVarPath = `/transaction-rollups/{sync_id}`
                .replace(`{${"sync_id"}}`, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of transaction rollup statuses based on the provided batch IDs.
         * @summary Retrieves the status of transaction rollups by batch IDs
         * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatuses: async (syncIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncIds' is not null or undefined
            assertParamExists('getTransactionRollupStatuses', 'syncIds', syncIds)
            const localVarPath = `/transaction-rollups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (syncIds) {
                localVarQueryParameter['sync_ids'] = syncIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the transaction rollup status for a specified batch ID.
         * @summary Retrieve a single transaction rollup status by batch ID
         * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRollupStatus(syncId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRollupStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRollupStatus(syncId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionRollupStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of transaction rollup statuses based on the provided batch IDs.
         * @summary Retrieves the status of transaction rollups by batch IDs
         * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRollupStatuses(syncIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionRollupStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRollupStatuses(syncIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionRollupStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Returns the transaction rollup status for a specified batch ID.
         * @summary Retrieve a single transaction rollup status by batch ID
         * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatus(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRollupStatus> {
            return localVarFp.getTransactionRollupStatus(syncId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of transaction rollup statuses based on the provided batch IDs.
         * @summary Retrieves the status of transaction rollups by batch IDs
         * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatuses(syncIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionRollupStatus>> {
            return localVarFp.getTransactionRollupStatuses(syncIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Returns the transaction rollup status for a specified batch ID.
     * @summary Retrieve a single transaction rollup status by batch ID
     * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionRollupStatus(syncId: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionRollupStatus(syncId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transaction rollup statuses based on the provided batch IDs.
     * @summary Retrieves the status of transaction rollups by batch IDs
     * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionRollupStatuses(syncIds: Array<string>, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionRollupStatuses(syncIds, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns account IDs that the user has edit access to.
         * @summary Get accounts with edit access
         * @param {number} userId User ID of the resource
         * @param {Array<number>} [accountIds] Comma separated list of account ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsEditAccess: async (userId: number, accountIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAccountsEditAccess', 'userId', userId)
            const localVarPath = `/users/{user_id}/account-contact/edit-access`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get roles for each areana
         * @summary Get roles for each arena
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserArenaRoles: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserArenaRoles', 'userId', userId)
            const localVarPath = `/users/{user_id}/arena_roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
         * @summary Get distribution batch with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatch: async (userId: number, distributionBatchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserDistributionBatch', 'userId', userId)
            // verify required parameter 'distributionBatchId' is not null or undefined
            assertParamExists('getUserDistributionBatch', 'distributionBatchId', distributionBatchId)
            const localVarPath = `/users/{user_id}/distribution_batch/{distribution_batch_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"distribution_batch_id"}}`, encodeURIComponent(String(distributionBatchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
         * @summary Get distribution batch distributions for a user_id with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatchDistributions: async (userId: number, distributionBatchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserDistributionBatchDistributions', 'userId', userId)
            // verify required parameter 'distributionBatchId' is not null or undefined
            assertParamExists('getUserDistributionBatchDistributions', 'distributionBatchId', distributionBatchId)
            const localVarPath = `/users/{user_id}/distribution_batch/{distribution_batch_id}/distributions`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"distribution_batch_id"}}`, encodeURIComponent(String(distributionBatchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
         * @summary Get users
         * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (globalIds?: Array<string>, ids?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (globalIds) {
                localVarQueryParameter['global_ids'] = globalIds.join(COLLECTION_FORMATS.csv);
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns account IDs that the user has edit access to.
         * @summary Get accounts with edit access
         * @param {number} userId User ID of the resource
         * @param {Array<number>} [accountIds] Comma separated list of account ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsEditAccess(userId: number, accountIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsEditAccess(userId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getAccountsEditAccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get roles for each areana
         * @summary Get roles for each arena
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserArenaRoles(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArenaRoles>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserArenaRoles(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserArenaRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
         * @summary Get distribution batch with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDistributionBatch(userId: number, distributionBatchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistributionBatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDistributionBatch(userId, distributionBatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserDistributionBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
         * @summary Get distribution batch distributions for a user_id with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDistributionBatchDistributions(userId: number, distributionBatchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Distribution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDistributionBatchDistributions(userId, distributionBatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserDistributionBatchDistributions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
         * @summary Get users
         * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(globalIds?: Array<string>, ids?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(globalIds, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Returns account IDs that the user has edit access to.
         * @summary Get accounts with edit access
         * @param {number} userId User ID of the resource
         * @param {Array<number>} [accountIds] Comma separated list of account ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsEditAccess(userId: number, accountIds?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getAccountsEditAccess(userId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get roles for each areana
         * @summary Get roles for each arena
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserArenaRoles(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ArenaRoles>> {
            return localVarFp.getUserArenaRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
         * @summary Get distribution batch with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatch(userId: number, distributionBatchId: number, options?: RawAxiosRequestConfig): AxiosPromise<DistributionBatch> {
            return localVarFp.getUserDistributionBatch(userId, distributionBatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
         * @summary Get distribution batch distributions for a user_id with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatchDistributions(userId: number, distributionBatchId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Distribution>> {
            return localVarFp.getUserDistributionBatchDistributions(userId, distributionBatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
         * @summary Get users
         * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(globalIds?: Array<string>, ids?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.getUsers(globalIds, ids, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Returns account IDs that the user has edit access to.
     * @summary Get accounts with edit access
     * @param {number} userId User ID of the resource
     * @param {Array<number>} [accountIds] Comma separated list of account ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAccountsEditAccess(userId: number, accountIds?: Array<number>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAccountsEditAccess(userId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get roles for each areana
     * @summary Get roles for each arena
     * @param {number} userId User ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserArenaRoles(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserArenaRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
     * @summary Get distribution batch with authorization checks
     * @param {number} userId User ID of the resource
     * @param {number} distributionBatchId Id of the distribution_batch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserDistributionBatch(userId: number, distributionBatchId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserDistributionBatch(userId, distributionBatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
     * @summary Get distribution batch distributions for a user_id with authorization checks
     * @param {number} userId User ID of the resource
     * @param {number} distributionBatchId Id of the distribution_batch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserDistributionBatchDistributions(userId: number, distributionBatchId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserDistributionBatchDistributions(userId, distributionBatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
     * @summary Get users
     * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
     * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(globalIds?: Array<string>, ids?: Array<number>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(globalIds, ids, options).then((request) => request(this.axios, this.basePath));
    }
}



