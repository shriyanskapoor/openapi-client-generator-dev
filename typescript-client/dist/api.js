"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Juniper Square Internal API
 * An internal API for inter-service communication at JSQ.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentPrefsApiFactory = exports.PaymentPrefsApiFp = exports.PaymentPrefsApiAxiosParamCreator = exports.FeatureFlagsApi = exports.FeatureFlagsApiFactory = exports.FeatureFlagsApiFp = exports.FeatureFlagsApiAxiosParamCreator = exports.EntitiesApi = exports.EntitiesApiFactory = exports.EntitiesApiFp = exports.EntitiesApiAxiosParamCreator = exports.DistributionBatchesApi = exports.DistributionBatchesApiFactory = exports.DistributionBatchesApiFp = exports.DistributionBatchesApiAxiosParamCreator = exports.DistributionApi = exports.DistributionApiFactory = exports.DistributionApiFp = exports.DistributionApiAxiosParamCreator = exports.DiligencesApi = exports.DiligencesApiFactory = exports.DiligencesApiFp = exports.DiligencesApiAxiosParamCreator = exports.BankAccountApi = exports.BankAccountApiFactory = exports.BankAccountApiFp = exports.BankAccountApiAxiosParamCreator = exports.ArenasApi = exports.ArenasApiFactory = exports.ArenasApiFp = exports.ArenasApiAxiosParamCreator = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.UpdatePaymentPrefOptionsVerificationStatusEnum = exports.TransactionRollupStatusStatusEnum = exports.ResponseStatus = exports.Permission = exports.PaymentPrefVerificationStatusEnum = exports.PaymentPrefPaymentMethodEnum = exports.ObjectType = exports.GranularPermission = exports.DocumentContentTypeEnum = exports.DocumentDocumentTypeEnum = exports.DiligenceType = exports.DiligenceStatus = exports.DiligenceCategory = exports.BulkAccountContactChangeNotifyRequestTypeEnum = exports.AllocationTypeCategoryEnum = void 0;
exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TransactionsApi = exports.TransactionsApiFactory = exports.TransactionsApiFp = exports.TransactionsApiAxiosParamCreator = exports.PositionsApi = exports.PositionsApiFactory = exports.PositionsApiFp = exports.PositionsApiAxiosParamCreator = exports.PermissionsApi = exports.PermissionsApiFactory = exports.PermissionsApiFp = exports.PermissionsApiAxiosParamCreator = exports.PaymentPrefsApi = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.AllocationTypeCategoryEnum = {
    CapitalCall: 'Capital Call',
    CapitalActivity: 'Capital Activity',
    DistributionAllocations: 'Distribution Allocations',
    NetIncomeAllocations: 'Net Income Allocations'
};
exports.BulkAccountContactChangeNotifyRequestTypeEnum = {
    AddContact: 'ADD_CONTACT',
    UpdateContact: 'UPDATE_CONTACT',
    RemoveContact: 'REMOVE_CONTACT'
};
/**
 * Category of Diligence
 * @export
 * @enum {string}
 */
exports.DiligenceCategory = {
    PaymentsOnboardingFlow: 'payments_onboarding_flow'
};
/**
 * Status of the diligence in the submission workflow
 * @export
 * @enum {string}
 */
exports.DiligenceStatus = {
    Started: 'started',
    PendingReview: 'pending_review',
    RequestedLpForInfo: 'requested_lp_for_info',
    InReview: 'in_review',
    PendingPeerReview: 'pending_peer_review',
    InPeerReview: 'in_peer_review',
    Confirmed: 'confirmed'
};
/**
 * Type of Diligence. Differs from category because category represents what type of service/entity is requesting the diligence. DiligenceType represents the type of diligence created
 * @export
 * @enum {string}
 */
exports.DiligenceType = {
    Kyc: 'kyc',
    WatchlistScreening: 'watchlist_screening',
    Manual: 'manual'
};
exports.DocumentDocumentTypeEnum = {
    IdentityDocument: 'identity_document',
    FormationDocument: 'formation_document',
    TaxDocument: 'tax_document',
    File: 'file',
    CorporateResolution: 'corporate_resolution',
    AuditedFinancial: 'audited_financial'
};
exports.DocumentContentTypeEnum = {
    ImageWebp: 'image/webp',
    ApplicationPdf: 'application/pdf',
    ImagePng: 'image/png',
    ImageJpeg: 'image/jpeg'
};
/**
 * Granular permission enum
 * @export
 * @enum {string}
 */
exports.GranularPermission = {
    ManagePortalSettings: 'CAN_MANAGE_PORTAL_SETTINGS',
    ManageGeneralSubscriptionSettings: 'CAN_MANAGE_GENERAL_SUBSCRIPTION_SETTINGS',
    ManageStaffAccess: 'CAN_MANAGE_STAFF_ACCESS',
    ManageSelf: 'CAN_MANAGE_SELF',
    ManageUserRoles: 'CAN_MANAGE_USER_ROLES',
    AssignAdministratorPermissionsToStaffUsers: 'CAN_ASSIGN_ADMINISTRATOR_PERMISSIONS_TO_STAFF_USERS',
    ManageAuthentication: 'CAN_MANAGE_AUTHENTICATION',
    ManageAgreements: 'CAN_MANAGE_AGREEMENTS',
    ManageDataFields: 'CAN_MANAGE_DATA_FIELDS',
    AccessAuditLog: 'CAN_ACCESS_AUDIT_LOG',
    ConfigDocumentCategories: 'CAN_CONFIG_DOCUMENT_CATEGORIES',
    ConfigEmailDistributionLists: 'CAN_CONFIG_EMAIL_DISTRIBUTION_LISTS',
    ConfigCrmNotificationLists: 'CAN_CONFIG_CRM_NOTIFICATION_LISTS',
    ConfigOwnershipUnitsAndPercentages: 'CAN_CONFIG_OWNERSHIP_UNITS_AND_PERCENTAGES',
    ConfigDistributionsAndCapitalTransactions: 'CAN_CONFIG_DISTRIBUTIONS_AND_CAPITAL_TRANSACTIONS',
    ConfigNetIncomeAndNavComponents: 'CAN_CONFIG_NET_INCOME_AND_NAV_COMPONENTS',
    ConfigEntitySubtypes: 'CAN_CONFIG_ENTITY_SUBTYPES',
    ConfigMetricsSettings: 'CAN_CONFIG_METRICS_SETTINGS',
    ConfigWatermarkTemplates: 'CAN_CONFIG_WATERMARK_TEMPLATES',
    ConfigManagementFees: 'CAN_CONFIG_MANAGEMENT_FEES',
    ConfigOrganizationSettings: 'CAN_CONFIG_ORGANIZATION_SETTINGS',
    ConfigESignatures: 'CAN_CONFIG_E_SIGNATURES',
    ConfigStatementNotices: 'CAN_CONFIG_STATEMENT_NOTICES',
    ConfigStationeryLibrary: 'CAN_CONFIG_STATIONERY_LIBRARY',
    ConfigReportingTemplate: 'CAN_CONFIG_REPORTING_TEMPLATE',
    ConfigIntegrations: 'CAN_CONFIG_INTEGRATIONS',
    ConfigMappings: 'CAN_CONFIG_MAPPINGS',
    AccessProspectSubscription: 'CAN_ACCESS_PROSPECT_SUBSCRIPTION'
};
/**
 * String representation of ObjectType enum
 * @export
 * @enum {string}
 */
exports.ObjectType = {
    Arena: 'arena',
    User: 'user',
    Contact: 'contact',
    Offering: 'offering',
    Prospect: 'prospect',
    Account: 'account',
    Property: 'property',
    CommPref: 'comm_pref',
    Position: 'position',
    Document: 'document',
    EmailBatch: 'email_batch',
    CapitalCallBatch: 'capital_call_batch',
    DistributionBatch: 'distribution_batch',
    Transaction: 'transaction',
    Asset: 'asset',
    ProspectContactMap: 'prospect_contact_map',
    DataRoom: 'data_room',
    NetIncomeBatch: 'net_income_batch',
    Publication: 'publication',
    SubscriptionBatch: 'subscription_batch',
    Subscription: 'subscription',
    EventLog: 'event_log',
    PaymentBatch: 'payment_batch',
    ManagementFeeBatch: 'management_fee_batch',
    Task: 'task',
    Lead: 'lead',
    CrmNotificationList: 'crm_notification_list',
    NavBatch: 'nav_batch',
    Loan: 'loan',
    AssetDateSampledData: 'asset_date_sampled_data',
    TransactionBatch: 'transaction_batch',
    UnitValue: 'unit_value',
    UnitValueBatch: 'unit_value_batch',
    CapitalCall: 'capital_call',
    Distribution: 'distribution',
    NetIncome: 'net_income',
    Nav: 'nav',
    Note: 'note',
    StoredEmail: 'stored_email',
    Email: 'email',
    InvestorDiligence: 'investor_diligence',
    WatchlistScreeningDetail: 'watchlist_screening_detail',
    KycDetail: 'kyc_detail',
    KycDocument: 'kyc_document',
    KycDocumentVersion: 'kyc_document_version',
    ImportTemplate: 'import_template',
    KycDocumentVersionActivity: 'kyc_document_version_activity',
    Acquisition: 'acquisition',
    Disposition: 'disposition',
    FeatureFlag: 'feature_flag',
    PaymentPref: 'payment_pref',
    DocumentCategory: 'document_category',
    ConsolidatedPaymentBatch: 'consolidated_payment_batch',
    ESignatureDocument: 'e_signature_document',
    ESignatureRequestTemplate: 'e_signature_request_template',
    ESignatureGpSigner: 'e_signature_gp_signer',
    ESignatureRequestBatch: 'e_signature_request_batch',
    ESignatureRequest: 'e_signature_request',
    ESignatureRequestRecipient: 'e_signature_request_recipient',
    ESignatureLpSigner: 'e_signature_lp_signer',
    ESignatureLpConfigurator: 'e_signature_lp_configurator',
    Payment: 'payment',
    BankAccount: 'bank_account',
    TwrPeriodMetric: 'twr_period_metric',
    FieldAccessRole: 'field_access_role',
    FieldAccessRoleObjectMap: 'field_access_role_object_map',
    Location: 'location',
    ProductType: 'product_type',
    DocumentFolder: 'document_folder',
    LpConsolidationRequest: 'lp_consolidation_request',
    FundAdminService: 'fund_admin_service',
    EntityCollection: 'entity_collection',
    ComplianceProfile: 'compliance_profile'
};
exports.PaymentPrefPaymentMethodEnum = {
    Ach: 'ACH',
    Check: 'Check',
    Wire: 'Wire'
};
exports.PaymentPrefVerificationStatusEnum = {
    Verified: 'verified',
    Unverified: 'unverified',
    Error: 'error'
};
/**
 * String representation of Permission enum
 * @export
 * @enum {string}
 */
exports.Permission = {
    Create: 'create',
    Read: 'read',
    Update: 'update',
    Delete: 'delete',
    Administer: 'administer',
    Download: 'download',
    ManagePortal: 'manage_portal',
    LimitedRead: 'limited_read',
    PublishTransactions: 'publish_transactions',
    LimitedEdit: 'limited_edit'
};
/**
 * Response status
 * @export
 * @enum {string}
 */
exports.ResponseStatus = {
    Success: 'Success',
    Failure: 'Failure'
};
exports.TransactionRollupStatusStatusEnum = {
    Received: 'received',
    Completed: 'completed',
    Failed: 'failed'
};
exports.UpdatePaymentPrefOptionsVerificationStatusEnum = {
    Verified: 'verified',
    Unverified: 'unverified',
    Error: 'error'
};
/**
 * AccountsApi - axios parameter creator
 * @export
 */
const AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * API for account contact bulk removal
         * @summary API for account contact bulk removal
         * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkRemove: async (bulkAccountContactRemoveRequestBody, options = {}) => {
            const localVarPath = `/account-contact/bulk-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bulkAccountContactRemoveRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for account contact bulk update
         * @summary API for account contact bulk update
         * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkUpdate: async (bulkAccountContactUpdateRequestBody, options = {}) => {
            const localVarPath = `/account-contact/bulk-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bulkAccountContactUpdateRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for account contact change notification
         * @summary API for account contact change notification
         * @param {number} userId User ID of the resource
         * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactChangeNotify: async (userId, bulkAccountContactChangeNotify, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('accountContactChangeNotify', 'userId', userId);
            const localVarPath = `/users/{user_id}/account-contact/bulk-notify`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bulkAccountContactChangeNotify, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
const AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * API for account contact bulk removal
         * @summary API for account contact bulk removal
         * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.accountContactBulkRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for account contact bulk update
         * @summary API for account contact bulk update
         * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.accountContactBulkUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for account contact change notification
         * @summary API for account contact change notification
         * @param {number} userId User ID of the resource
         * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.accountContactChangeNotify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
const AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountsApiFp)(configuration);
    return {
        /**
         * API for account contact bulk removal
         * @summary API for account contact bulk removal
         * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options) {
            return localVarFp.accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * API for account contact bulk update
         * @summary API for account contact bulk update
         * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options) {
            return localVarFp.accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * API for account contact change notification
         * @summary API for account contact change notification
         * @param {number} userId User ID of the resource
         * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options) {
            return localVarFp.accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * API for account contact bulk removal
     * @summary API for account contact bulk removal
     * @param {BulkAccountContactRemoveRequestBody} [bulkAccountContactRemoveRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options) {
        return (0, exports.AccountsApiFp)(this.configuration).accountContactBulkRemove(bulkAccountContactRemoveRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API for account contact bulk update
     * @summary API for account contact bulk update
     * @param {BulkAccountContactUpdateRequestBody} [bulkAccountContactUpdateRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options) {
        return (0, exports.AccountsApiFp)(this.configuration).accountContactBulkUpdate(bulkAccountContactUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API for account contact change notification
     * @summary API for account contact change notification
     * @param {number} userId User ID of the resource
     * @param {BulkAccountContactChangeNotify} [bulkAccountContactChangeNotify]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options) {
        return (0, exports.AccountsApiFp)(this.configuration).accountContactChangeNotify(userId, bulkAccountContactChangeNotify, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * ArenasApi - axios parameter creator
 * @export
 */
const ArenasApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get an un-paginated list of allocation types.
         * @summary Get a list of allocation types for the given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocationTypes: async (arenaId, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getAllocationTypes', 'arenaId', arenaId);
            const localVarPath = `/arenas/{arena_id}/allocation_types`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an arena by ID.
         * @summary Get arena
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArena: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getArena', 'id', id);
            const localVarPath = `/arenas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get allocationTypes for a given arena by ID
         * @summary Get allocation types for a given arena by ID
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaNetIncomeTypes: async (arenaId, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getArenaNetIncomeTypes', 'arenaId', arenaId);
            const localVarPath = `/arenas/{arena_id}/net_income_allocation_types`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment settings for a given arena by ID
         * @summary Get payment settings for a given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaPaymentSettings: async (arenaId, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getArenaPaymentSettings', 'arenaId', arenaId);
            const localVarPath = `/arenas/{arena_id}/payment_settings`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
         * @summary Get a list of Arenas
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenas: async (ids, options = {}) => {
            const localVarPath = `/arenas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ArenasApiAxiosParamCreator = ArenasApiAxiosParamCreator;
/**
 * ArenasApi - functional programming interface
 * @export
 */
const ArenasApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ArenasApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get an un-paginated list of allocation types.
         * @summary Get a list of allocation types for the given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllocationTypes(arenaId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllocationTypes(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ArenasApi.getAllocationTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an arena by ID.
         * @summary Get arena
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArena(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArena(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ArenasApi.getArena']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get allocationTypes for a given arena by ID
         * @summary Get allocation types for a given arena by ID
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaNetIncomeTypes(arenaId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaNetIncomeTypes(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ArenasApi.getArenaNetIncomeTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get payment settings for a given arena by ID
         * @summary Get payment settings for a given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaPaymentSettings(arenaId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaPaymentSettings(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ArenasApi.getArenaPaymentSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
         * @summary Get a list of Arenas
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenas(ids, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenas(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ArenasApi.getArenas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ArenasApiFp = ArenasApiFp;
/**
 * ArenasApi - factory interface
 * @export
 */
const ArenasApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ArenasApiFp)(configuration);
    return {
        /**
         * Get an un-paginated list of allocation types.
         * @summary Get a list of allocation types for the given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocationTypes(arenaId, options) {
            return localVarFp.getAllocationTypes(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an arena by ID.
         * @summary Get arena
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArena(id, options) {
            return localVarFp.getArena(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get allocationTypes for a given arena by ID
         * @summary Get allocation types for a given arena by ID
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaNetIncomeTypes(arenaId, options) {
            return localVarFp.getArenaNetIncomeTypes(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment settings for a given arena by ID
         * @summary Get payment settings for a given arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaPaymentSettings(arenaId, options) {
            return localVarFp.getArenaPaymentSettings(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
         * @summary Get a list of Arenas
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenas(ids, options) {
            return localVarFp.getArenas(ids, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArenasApiFactory = ArenasApiFactory;
/**
 * ArenasApi - object-oriented interface
 * @export
 * @class ArenasApi
 * @extends {BaseAPI}
 */
class ArenasApi extends base_1.BaseAPI {
    /**
     * Get an un-paginated list of allocation types.
     * @summary Get a list of allocation types for the given arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    getAllocationTypes(arenaId, options) {
        return (0, exports.ArenasApiFp)(this.configuration).getAllocationTypes(arenaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an arena by ID.
     * @summary Get arena
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    getArena(id, options) {
        return (0, exports.ArenasApiFp)(this.configuration).getArena(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get allocationTypes for a given arena by ID
     * @summary Get allocation types for a given arena by ID
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    getArenaNetIncomeTypes(arenaId, options) {
        return (0, exports.ArenasApiFp)(this.configuration).getArenaNetIncomeTypes(arenaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payment settings for a given arena by ID
     * @summary Get payment settings for a given arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    getArenaPaymentSettings(arenaId, options) {
        return (0, exports.ArenasApiFp)(this.configuration).getArenaPaymentSettings(arenaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an un-paginated list of all arenas, optionally filtered by a list of arena IDs.
     * @summary Get a list of Arenas
     * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArenasApi
     */
    getArenas(ids, options) {
        return (0, exports.ArenasApiFp)(this.configuration).getArenas(ids, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArenasApi = ArenasApi;
/**
 * BankAccountApi - axios parameter creator
 * @export
 */
const BankAccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get the name of the provided bank_account_id
         * @summary Get a bank account (BankAccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankAccount: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBankAccount', 'id', id);
            const localVarPath = `/bank_account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.BankAccountApiAxiosParamCreator = BankAccountApiAxiosParamCreator;
/**
 * BankAccountApi - functional programming interface
 * @export
 */
const BankAccountApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BankAccountApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get the name of the provided bank_account_id
         * @summary Get a bank account (BankAccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankAccount(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankAccount(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['BankAccountApi.getBankAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.BankAccountApiFp = BankAccountApiFp;
/**
 * BankAccountApi - factory interface
 * @export
 */
const BankAccountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BankAccountApiFp)(configuration);
    return {
        /**
         * Get the name of the provided bank_account_id
         * @summary Get a bank account (BankAccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankAccount(id, options) {
            return localVarFp.getBankAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BankAccountApiFactory = BankAccountApiFactory;
/**
 * BankAccountApi - object-oriented interface
 * @export
 * @class BankAccountApi
 * @extends {BaseAPI}
 */
class BankAccountApi extends base_1.BaseAPI {
    /**
     * Get the name of the provided bank_account_id
     * @summary Get a bank account (BankAccountModel)
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountApi
     */
    getBankAccount(id, options) {
        return (0, exports.BankAccountApiFp)(this.configuration).getBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BankAccountApi = BankAccountApi;
/**
 * DiligencesApi - axios parameter creator
 * @export
 */
const DiligencesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
         * @summary Create a diligence object and underlying KYC/watchlists
         * @param {CreateDiligence} [createDiligence]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiligences: async (createDiligence, options = {}) => {
            const localVarPath = `/diligences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createDiligence, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of diligences
         * @summary Get a list of diligences
         * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
         * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
         * @param {number} [objectId] Object ID to filter on
         * @param {Array<number>} [objectIds] Object IDs to filter on
         * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
         * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiligences: async (diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options = {}) => {
            // verify required parameter 'diligenceCategory' is not null or undefined
            (0, common_1.assertParamExists)('getDiligences', 'diligenceCategory', diligenceCategory);
            const localVarPath = `/diligences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (diligenceCategory !== undefined) {
                localVarQueryParameter['diligence_category'] = diligenceCategory;
            }
            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }
            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }
            if (objectIds) {
                localVarQueryParameter['object_ids'] = objectIds.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (diligenceType !== undefined) {
                localVarQueryParameter['diligence_type'] = diligenceType;
            }
            if (diligenceStatus !== undefined) {
                localVarQueryParameter['diligence_status'] = diligenceStatus;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DiligencesApiAxiosParamCreator = DiligencesApiAxiosParamCreator;
/**
 * DiligencesApi - functional programming interface
 * @export
 */
const DiligencesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DiligencesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
         * @summary Create a diligence object and underlying KYC/watchlists
         * @param {CreateDiligence} [createDiligence]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiligences(createDiligence, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiligences(createDiligence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['DiligencesApi.createDiligences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of diligences
         * @summary Get a list of diligences
         * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
         * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
         * @param {number} [objectId] Object ID to filter on
         * @param {Array<number>} [objectIds] Object IDs to filter on
         * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
         * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['DiligencesApi.getDiligences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.DiligencesApiFp = DiligencesApiFp;
/**
 * DiligencesApi - factory interface
 * @export
 */
const DiligencesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DiligencesApiFp)(configuration);
    return {
        /**
         * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
         * @summary Create a diligence object and underlying KYC/watchlists
         * @param {CreateDiligence} [createDiligence]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiligences(createDiligence, options) {
            return localVarFp.createDiligences(createDiligence, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of diligences
         * @summary Get a list of diligences
         * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
         * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
         * @param {number} [objectId] Object ID to filter on
         * @param {Array<number>} [objectIds] Object IDs to filter on
         * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
         * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options) {
            return localVarFp.getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DiligencesApiFactory = DiligencesApiFactory;
/**
 * DiligencesApi - object-oriented interface
 * @export
 * @class DiligencesApi
 * @extends {BaseAPI}
 */
class DiligencesApi extends base_1.BaseAPI {
    /**
     * Create a diligence and underlying KYC/watchlists. This method is considered deprecated and used to bridge the gap until the compliance service API is fully available.
     * @summary Create a diligence object and underlying KYC/watchlists
     * @param {CreateDiligence} [createDiligence]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiligencesApi
     */
    createDiligences(createDiligence, options) {
        return (0, exports.DiligencesApiFp)(this.configuration).createDiligences(createDiligence, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an un-paginated list of diligences
     * @summary Get a list of diligences
     * @param {DiligenceCategory} diligenceCategory Category of diligences to filter on
     * @param {ObjectType} [objectType] Optional object_type to filter by. Should match an ObjectType enum.
     * @param {number} [objectId] Object ID to filter on
     * @param {Array<number>} [objectIds] Object IDs to filter on
     * @param {DiligenceType} [diligenceType] Type of Diligence to filter on
     * @param {DiligenceStatus} [diligenceStatus] Status of diligence in submission workflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiligencesApi
     */
    getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options) {
        return (0, exports.DiligencesApiFp)(this.configuration).getDiligences(diligenceCategory, objectType, objectId, objectIds, diligenceType, diligenceStatus, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DiligencesApi = DiligencesApi;
/**
 * DistributionApi - axios parameter creator
 * @export
 */
const DistributionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a distribution by the given distribution id. This does not handle auth.
         * @summary Get distribution
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistribution: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDistribution', 'id', id);
            const localVarPath = `/distributions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DistributionApiAxiosParamCreator = DistributionApiAxiosParamCreator;
/**
 * DistributionApi - functional programming interface
 * @export
 */
const DistributionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DistributionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get a distribution by the given distribution id. This does not handle auth.
         * @summary Get distribution
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistribution(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistribution(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['DistributionApi.getDistribution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.DistributionApiFp = DistributionApiFp;
/**
 * DistributionApi - factory interface
 * @export
 */
const DistributionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DistributionApiFp)(configuration);
    return {
        /**
         * Get a distribution by the given distribution id. This does not handle auth.
         * @summary Get distribution
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistribution(id, options) {
            return localVarFp.getDistribution(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DistributionApiFactory = DistributionApiFactory;
/**
 * DistributionApi - object-oriented interface
 * @export
 * @class DistributionApi
 * @extends {BaseAPI}
 */
class DistributionApi extends base_1.BaseAPI {
    /**
     * Get a distribution by the given distribution id. This does not handle auth.
     * @summary Get distribution
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    getDistribution(id, options) {
        return (0, exports.DistributionApiFp)(this.configuration).getDistribution(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DistributionApi = DistributionApi;
/**
 * DistributionBatchesApi - axios parameter creator
 * @export
 */
const DistributionBatchesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a distribution batch by ID. This does not handle auth checks.
         * @summary Get distribution batch no authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionBatch: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDistributionBatch', 'id', id);
            const localVarPath = `/distribution_batches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
         * @summary Get distributions for a distribution batch not authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionsForDistributionBatch: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDistributionsForDistributionBatch', 'id', id);
            const localVarPath = `/distribution_batches/{id}/distributions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DistributionBatchesApiAxiosParamCreator = DistributionBatchesApiAxiosParamCreator;
/**
 * DistributionBatchesApi - functional programming interface
 * @export
 */
const DistributionBatchesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DistributionBatchesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get a distribution batch by ID. This does not handle auth checks.
         * @summary Get distribution batch no authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistributionBatch(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistributionBatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['DistributionBatchesApi.getDistributionBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
         * @summary Get distributions for a distribution batch not authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistributionsForDistributionBatch(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistributionsForDistributionBatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['DistributionBatchesApi.getDistributionsForDistributionBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.DistributionBatchesApiFp = DistributionBatchesApiFp;
/**
 * DistributionBatchesApi - factory interface
 * @export
 */
const DistributionBatchesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DistributionBatchesApiFp)(configuration);
    return {
        /**
         * Get a distribution batch by ID. This does not handle auth checks.
         * @summary Get distribution batch no authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionBatch(id, options) {
            return localVarFp.getDistributionBatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
         * @summary Get distributions for a distribution batch not authorization checks
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionsForDistributionBatch(id, options) {
            return localVarFp.getDistributionsForDistributionBatch(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DistributionBatchesApiFactory = DistributionBatchesApiFactory;
/**
 * DistributionBatchesApi - object-oriented interface
 * @export
 * @class DistributionBatchesApi
 * @extends {BaseAPI}
 */
class DistributionBatchesApi extends base_1.BaseAPI {
    /**
     * Get a distribution batch by ID. This does not handle auth checks.
     * @summary Get distribution batch no authorization checks
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionBatchesApi
     */
    getDistributionBatch(id, options) {
        return (0, exports.DistributionBatchesApiFp)(this.configuration).getDistributionBatch(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get distributions for a distribution batch by distribution batch ID. This does not handle auth.
     * @summary Get distributions for a distribution batch not authorization checks
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionBatchesApi
     */
    getDistributionsForDistributionBatch(id, options) {
        return (0, exports.DistributionBatchesApiFp)(this.configuration).getDistributionsForDistributionBatch(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DistributionBatchesApi = DistributionBatchesApi;
/**
 * EntitiesApi - axios parameter creator
 * @export
 */
const EntitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get an un-paginated list of investment entities with their positions.
         * @summary Get a list of investment entities with their positions in an arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [entityIds] Comma separated list of entity ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithPositions: async (arenaId, entityIds, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getEntitiesWithPositions', 'arenaId', arenaId);
            const localVarPath = `/arenas/{arena_id}/entities`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (entityIds) {
                localVarQueryParameter['entity_ids'] = entityIds.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the name of the provided entity_id
         * @summary Get an entity (AccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getEntity', 'id', id);
            const localVarPath = `/entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of entity ids filtered by query params
         * @summary Get entity ids
         * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityIds: async (isFundAdmin, options = {}) => {
            const localVarPath = `/entity-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (isFundAdmin !== undefined) {
                localVarQueryParameter['is_fund_admin'] = isFundAdmin;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of positions in an investment entity.
         * @summary Get a list of positions in an investment entity.
         * @param {number} id Id of the resource
         * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityPositions: async (id, cabPeriodEnds, transactionDates, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getEntityPositions', 'id', id);
            const localVarPath = `/entities/{id}/positions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (cabPeriodEnds) {
                localVarQueryParameter['cab_period_ends'] = cabPeriodEnds.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (transactionDates) {
                localVarQueryParameter['transaction_dates'] = transactionDates.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EntitiesApiAxiosParamCreator = EntitiesApiAxiosParamCreator;
/**
 * EntitiesApi - functional programming interface
 * @export
 */
const EntitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EntitiesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get an un-paginated list of investment entities with their positions.
         * @summary Get a list of investment entities with their positions in an arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [entityIds] Comma separated list of entity ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitiesWithPositions(arenaId, entityIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitiesWithPositions(arenaId, entityIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['EntitiesApi.getEntitiesWithPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the name of the provided entity_id
         * @summary Get an entity (AccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntity(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['EntitiesApi.getEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of entity ids filtered by query params
         * @summary Get entity ids
         * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityIds(isFundAdmin, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityIds(isFundAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['EntitiesApi.getEntityIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of positions in an investment entity.
         * @summary Get a list of positions in an investment entity.
         * @param {number} id Id of the resource
         * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityPositions(id, cabPeriodEnds, transactionDates, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityPositions(id, cabPeriodEnds, transactionDates, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['EntitiesApi.getEntityPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.EntitiesApiFp = EntitiesApiFp;
/**
 * EntitiesApi - factory interface
 * @export
 */
const EntitiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EntitiesApiFp)(configuration);
    return {
        /**
         * Get an un-paginated list of investment entities with their positions.
         * @summary Get a list of investment entities with their positions in an arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [entityIds] Comma separated list of entity ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithPositions(arenaId, entityIds, options) {
            return localVarFp.getEntitiesWithPositions(arenaId, entityIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the name of the provided entity_id
         * @summary Get an entity (AccountModel)
         * @param {number} id Id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(id, options) {
            return localVarFp.getEntity(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of entity ids filtered by query params
         * @summary Get entity ids
         * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityIds(isFundAdmin, options) {
            return localVarFp.getEntityIds(isFundAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of positions in an investment entity.
         * @summary Get a list of positions in an investment entity.
         * @param {number} id Id of the resource
         * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityPositions(id, cabPeriodEnds, transactionDates, options) {
            return localVarFp.getEntityPositions(id, cabPeriodEnds, transactionDates, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EntitiesApiFactory = EntitiesApiFactory;
/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
class EntitiesApi extends base_1.BaseAPI {
    /**
     * Get an un-paginated list of investment entities with their positions.
     * @summary Get a list of investment entities with their positions in an arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {Array<string>} [entityIds] Comma separated list of entity ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntitiesWithPositions(arenaId, entityIds, options) {
        return (0, exports.EntitiesApiFp)(this.configuration).getEntitiesWithPositions(arenaId, entityIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the name of the provided entity_id
     * @summary Get an entity (AccountModel)
     * @param {number} id Id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntity(id, options) {
        return (0, exports.EntitiesApiFp)(this.configuration).getEntity(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an un-paginated list of entity ids filtered by query params
     * @summary Get entity ids
     * @param {boolean} [isFundAdmin] Flag to fetch FA only resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityIds(isFundAdmin, options) {
        return (0, exports.EntitiesApiFp)(this.configuration).getEntityIds(isFundAdmin, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an un-paginated list of positions in an investment entity.
     * @summary Get a list of positions in an investment entity.
     * @param {number} id Id of the resource
     * @param {Array<string>} [cabPeriodEnds] Comma separated list of dates for calculating cab. Date format should be YYYY-MM-DDThh:mm:ssZ.
     * @param {Array<string>} [transactionDates] Comma separated list of dates. Format should be YYYY-MM-DDThh:mm:ssZ.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityPositions(id, cabPeriodEnds, transactionDates, options) {
        return (0, exports.EntitiesApiFp)(this.configuration).getEntityPositions(id, cabPeriodEnds, transactionDates, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EntitiesApi = EntitiesApi;
/**
 * FeatureFlagsApi - axios parameter creator
 * @export
 */
const FeatureFlagsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Bulk update the state of arena feature flags.
         * @summary Bulk Update Arena Feature Flags
         * @param {number} arenaId Id of the arena to operate within
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateArenaFeatureFlags: async (arenaId, bulkUpdateFeatureFlags, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('bulkUpdateArenaFeatureFlags', 'arenaId', arenaId);
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication csrf-token required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-CSRF-Token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bulkUpdateFeatureFlags, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk update the state of developer feature flags.
         * @summary Bulk Update Developer Feature Flags
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateDeveloperFeatureFlags: async (bulkUpdateFeatureFlags, options = {}) => {
            const localVarPath = `/feature-flags/developer-feature-flags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication csrf-token required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-CSRF-Token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bulkUpdateFeatureFlags, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an arena feature flag by feature flag name and arena domain
         * @summary Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlag: async (arenaId, featureFlagName, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getArenaFeatureFlag', 'arenaId', arenaId);
            // verify required parameter 'featureFlagName' is not null or undefined
            (0, common_1.assertParamExists)('getArenaFeatureFlag', 'featureFlagName', featureFlagName);
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/{feature_flag_name}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all arena-level feature flags for an arena.
         * @summary Feature Flags for Arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlags: async (arenaId, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getArenaFeatureFlags', 'arenaId', arenaId);
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a developer feature flag by name.
         * @summary Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlag: async (featureFlagName, options = {}) => {
            // verify required parameter 'featureFlagName' is not null or undefined
            (0, common_1.assertParamExists)('getDeveloperFeatureFlag', 'featureFlagName', featureFlagName);
            const localVarPath = `/feature-flags/developer-feature-flags/{feature_flag_name}/`
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all developer feature flags.
         * @summary Developer Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlags: async (options = {}) => {
            const localVarPath = `/feature-flags/developer-feature-flags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a developer feature flag
         * @summary Update Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArenaFeatureFlag: async (arenaId, featureFlagName, updateFeatureFlag, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('updateArenaFeatureFlag', 'arenaId', arenaId);
            // verify required parameter 'featureFlagName' is not null or undefined
            (0, common_1.assertParamExists)('updateArenaFeatureFlag', 'featureFlagName', featureFlagName);
            const localVarPath = `/feature-flags/arena-feature-flags/{arena_id}/{feature_flag_name}/`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateFeatureFlag, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a developer feature flag
         * @summary Update Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeveloperFeatureFlag: async (featureFlagName, updateFeatureFlag, options = {}) => {
            // verify required parameter 'featureFlagName' is not null or undefined
            (0, common_1.assertParamExists)('updateDeveloperFeatureFlag', 'featureFlagName', featureFlagName);
            const localVarPath = `/feature-flags/developer-feature-flags/{feature_flag_name}/`
                .replace(`{${"feature_flag_name"}}`, encodeURIComponent(String(featureFlagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateFeatureFlag, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FeatureFlagsApiAxiosParamCreator = FeatureFlagsApiAxiosParamCreator;
/**
 * FeatureFlagsApi - functional programming interface
 * @export
 */
const FeatureFlagsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FeatureFlagsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Bulk update the state of arena feature flags.
         * @summary Bulk Update Arena Feature Flags
         * @param {number} arenaId Id of the arena to operate within
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.bulkUpdateArenaFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk update the state of developer feature flags.
         * @summary Bulk Update Developer Feature Flags
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.bulkUpdateDeveloperFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves an arena feature flag by feature flag name and arena domain
         * @summary Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaFeatureFlag(arenaId, featureFlagName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaFeatureFlag(arenaId, featureFlagName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.getArenaFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all arena-level feature flags for an arena.
         * @summary Feature Flags for Arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArenaFeatureFlags(arenaId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArenaFeatureFlags(arenaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.getArenaFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a developer feature flag by name.
         * @summary Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperFeatureFlag(featureFlagName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperFeatureFlag(featureFlagName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.getDeveloperFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all developer feature flags.
         * @summary Developer Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperFeatureFlags(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperFeatureFlags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.getDeveloperFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a developer feature flag
         * @summary Update Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.updateArenaFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a developer feature flag
         * @summary Update Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FeatureFlagsApi.updateDeveloperFeatureFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.FeatureFlagsApiFp = FeatureFlagsApiFp;
/**
 * FeatureFlagsApi - factory interface
 * @export
 */
const FeatureFlagsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FeatureFlagsApiFp)(configuration);
    return {
        /**
         * Bulk update the state of arena feature flags.
         * @summary Bulk Update Arena Feature Flags
         * @param {number} arenaId Id of the arena to operate within
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options) {
            return localVarFp.bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk update the state of developer feature flags.
         * @summary Bulk Update Developer Feature Flags
         * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options) {
            return localVarFp.bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an arena feature flag by feature flag name and arena domain
         * @summary Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlag(arenaId, featureFlagName, options) {
            return localVarFp.getArenaFeatureFlag(arenaId, featureFlagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all arena-level feature flags for an arena.
         * @summary Feature Flags for Arena
         * @param {number} arenaId Id of the arena to operate within
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArenaFeatureFlags(arenaId, options) {
            return localVarFp.getArenaFeatureFlags(arenaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a developer feature flag by name.
         * @summary Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlag(featureFlagName, options) {
            return localVarFp.getDeveloperFeatureFlag(featureFlagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all developer feature flags.
         * @summary Developer Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperFeatureFlags(options) {
            return localVarFp.getDeveloperFeatureFlags(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a developer feature flag
         * @summary Update Arena Feature Flag
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options) {
            return localVarFp.updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a developer feature flag
         * @summary Update Developer Feature Flag
         * @param {string} featureFlagName Name of the feature flag to retrieve
         * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options) {
            return localVarFp.updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FeatureFlagsApiFactory = FeatureFlagsApiFactory;
/**
 * FeatureFlagsApi - object-oriented interface
 * @export
 * @class FeatureFlagsApi
 * @extends {BaseAPI}
 */
class FeatureFlagsApi extends base_1.BaseAPI {
    /**
     * Bulk update the state of arena feature flags.
     * @summary Bulk Update Arena Feature Flags
     * @param {number} arenaId Id of the arena to operate within
     * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update arena feature flags in bulk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).bulkUpdateArenaFeatureFlags(arenaId, bulkUpdateFeatureFlags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Bulk update the state of developer feature flags.
     * @summary Bulk Update Developer Feature Flags
     * @param {BulkUpdateFeatureFlags} [bulkUpdateFeatureFlags] Fields used to update developer feature flags in bulk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).bulkUpdateDeveloperFeatureFlags(bulkUpdateFeatureFlags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves an arena feature flag by feature flag name and arena domain
     * @summary Arena Feature Flag
     * @param {number} arenaId Id of the arena to operate within
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    getArenaFeatureFlag(arenaId, featureFlagName, options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).getArenaFeatureFlag(arenaId, featureFlagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all arena-level feature flags for an arena.
     * @summary Feature Flags for Arena
     * @param {number} arenaId Id of the arena to operate within
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    getArenaFeatureFlags(arenaId, options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).getArenaFeatureFlags(arenaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a developer feature flag by name.
     * @summary Developer Feature Flag
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    getDeveloperFeatureFlag(featureFlagName, options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).getDeveloperFeatureFlag(featureFlagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all developer feature flags.
     * @summary Developer Feature Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    getDeveloperFeatureFlags(options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).getDeveloperFeatureFlags(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a developer feature flag
     * @summary Update Arena Feature Flag
     * @param {number} arenaId Id of the arena to operate within
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) an arena feature flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).updateArenaFeatureFlag(arenaId, featureFlagName, updateFeatureFlag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a developer feature flag
     * @summary Update Developer Feature Flag
     * @param {string} featureFlagName Name of the feature flag to retrieve
     * @param {UpdateFeatureFlag} [updateFeatureFlag] Fields used to update (patch) a developer feature flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options) {
        return (0, exports.FeatureFlagsApiFp)(this.configuration).updateDeveloperFeatureFlag(featureFlagName, updateFeatureFlag, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FeatureFlagsApi = FeatureFlagsApi;
/**
 * PaymentPrefsApi - axios parameter creator
 * @export
 */
const PaymentPrefsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
         * @summary Get a list of payment prefs
         * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPrefs: async (ids, options = {}) => {
            // verify required parameter 'ids' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentPrefs', 'ids', ids);
            const localVarPath = `/payment_prefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
         * @summary Update payment pref
         * @param {number} id Id of the resource
         * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentPref: async (id, updatePaymentPrefOptions, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updatePaymentPref', 'id', id);
            const localVarPath = `/payment_prefs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updatePaymentPrefOptions, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PaymentPrefsApiAxiosParamCreator = PaymentPrefsApiAxiosParamCreator;
/**
 * PaymentPrefsApi - functional programming interface
 * @export
 */
const PaymentPrefsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentPrefsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
         * @summary Get a list of payment prefs
         * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentPrefs(ids, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentPrefs(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PaymentPrefsApi.getPaymentPrefs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
         * @summary Update payment pref
         * @param {number} id Id of the resource
         * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentPref(id, updatePaymentPrefOptions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentPref(id, updatePaymentPrefOptions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PaymentPrefsApi.updatePaymentPref']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PaymentPrefsApiFp = PaymentPrefsApiFp;
/**
 * PaymentPrefsApi - factory interface
 * @export
 */
const PaymentPrefsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentPrefsApiFp)(configuration);
    return {
        /**
         * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
         * @summary Get a list of payment prefs
         * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPrefs(ids, options) {
            return localVarFp.getPaymentPrefs(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
         * @summary Update payment pref
         * @param {number} id Id of the resource
         * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentPref(id, updatePaymentPrefOptions, options) {
            return localVarFp.updatePaymentPref(id, updatePaymentPrefOptions, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PaymentPrefsApiFactory = PaymentPrefsApiFactory;
/**
 * PaymentPrefsApi - object-oriented interface
 * @export
 * @class PaymentPrefsApi
 * @extends {BaseAPI}
 */
class PaymentPrefsApi extends base_1.BaseAPI {
    /**
     * Get an un-paginated list of payment prefs filtered by a required list of payment pref IDs.
     * @summary Get a list of payment prefs
     * @param {Array<number>} ids Required comma separated list of ids to filter resources by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentPrefsApi
     */
    getPaymentPrefs(ids, options) {
        return (0, exports.PaymentPrefsApiFp)(this.configuration).getPaymentPrefs(ids, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update (patch) the fields for a specific payment pref. This only supports verification status at the moment.
     * @summary Update payment pref
     * @param {number} id Id of the resource
     * @param {UpdatePaymentPrefOptions} [updatePaymentPrefOptions] Fields used to update a payment pref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentPrefsApi
     */
    updatePaymentPref(id, updatePaymentPrefOptions, options) {
        return (0, exports.PaymentPrefsApiFp)(this.configuration).updatePaymentPref(id, updatePaymentPrefOptions, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentPrefsApi = PaymentPrefsApi;
/**
 * PermissionsApi - axios parameter creator
 * @export
 */
const PermissionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of granular permissions given user has.
         * @summary Returns a list of granular permissions given user has.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGranularPermissions: async (arenaId, userId, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getGranularPermissions', 'arenaId', arenaId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getGranularPermissions', 'userId', userId);
            const localVarPath = `/arenas/{arena_id}/users/{user_id}/granular_permissions`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @param {number} userId Required user_id to filter by.
         * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
         * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
         * @param {Array<Permission>} permissions List of object level permissions to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectLevelPermissions: async (userId, objectType, objectIds, permissions, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getObjectLevelPermissions', 'userId', userId);
            // verify required parameter 'objectType' is not null or undefined
            (0, common_1.assertParamExists)('getObjectLevelPermissions', 'objectType', objectType);
            // verify required parameter 'objectIds' is not null or undefined
            (0, common_1.assertParamExists)('getObjectLevelPermissions', 'objectIds', objectIds);
            // verify required parameter 'permissions' is not null or undefined
            (0, common_1.assertParamExists)('getObjectLevelPermissions', 'permissions', permissions);
            const localVarPath = `/object_level_permission`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }
            if (objectIds) {
                localVarQueryParameter['object_ids'] = objectIds.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (permissions) {
                localVarQueryParameter['permissions'] = permissions;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PermissionsApiAxiosParamCreator = PermissionsApiAxiosParamCreator;
/**
 * PermissionsApi - functional programming interface
 * @export
 */
const PermissionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PermissionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of granular permissions given user has.
         * @summary Returns a list of granular permissions given user has.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGranularPermissions(arenaId, userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGranularPermissions(arenaId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PermissionsApi.getGranularPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @param {number} userId Required user_id to filter by.
         * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
         * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
         * @param {Array<Permission>} permissions List of object level permissions to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectLevelPermissions(userId, objectType, objectIds, permissions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectLevelPermissions(userId, objectType, objectIds, permissions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PermissionsApi.getObjectLevelPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PermissionsApiFp = PermissionsApiFp;
/**
 * PermissionsApi - factory interface
 * @export
 */
const PermissionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PermissionsApiFp)(configuration);
    return {
        /**
         * Returns a list of granular permissions given user has.
         * @summary Returns a list of granular permissions given user has.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGranularPermissions(arenaId, userId, options) {
            return localVarFp.getGranularPermissions(arenaId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
         * @param {number} userId Required user_id to filter by.
         * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
         * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
         * @param {Array<Permission>} permissions List of object level permissions to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectLevelPermissions(userId, objectType, objectIds, permissions, options) {
            return localVarFp.getObjectLevelPermissions(userId, objectType, objectIds, permissions, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PermissionsApiFactory = PermissionsApiFactory;
/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
class PermissionsApi extends base_1.BaseAPI {
    /**
     * Returns a list of granular permissions given user has.
     * @summary Returns a list of granular permissions given user has.
     * @param {number} arenaId Id of the arena to operate within
     * @param {number} userId User ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    getGranularPermissions(arenaId, userId, options) {
        return (0, exports.PermissionsApiFp)(this.configuration).getGranularPermissions(arenaId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
     * @summary Determines if a user has object level authorization provided as input an objectType, [IDs], and [Permissions]. For staff users, permissions checks are only valid in an arena with ArenaFeatureFlags.advanced_permissions enabled. For portal users, only read permissions checks are allowed.
     * @param {number} userId Required user_id to filter by.
     * @param {ObjectType} objectType Required object_type to filter by. Should match an ObjectType enum.
     * @param {Array<number>} objectIds List of objects_ids of the corresponding ObjectType
     * @param {Array<Permission>} permissions List of object level permissions to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    getObjectLevelPermissions(userId, objectType, objectIds, permissions, options) {
        return (0, exports.PermissionsApiFp)(this.configuration).getObjectLevelPermissions(userId, objectType, objectIds, permissions, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PermissionsApi = PermissionsApi;
/**
 * PositionsApi - axios parameter creator
 * @export
 */
const PositionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets position of a specific arena and source
         * @summary Gets position of a specific arena and source
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalPosition: async (arenaId, externalPositionId, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalPosition', 'arenaId', arenaId);
            // verify required parameter 'externalPositionId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalPosition', 'externalPositionId', externalPositionId);
            const localVarPath = `/arenas/{arena_id}/external_positions/{external_position_id}`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"external_position_id"}}`, encodeURIComponent(String(externalPositionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
         * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} entityId Id of the entity
         * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
         * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpcoPositions: async (arenaId, entityId, excludeInactive, asOfDate, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getOpcoPositions', 'arenaId', arenaId);
            // verify required parameter 'entityId' is not null or undefined
            (0, common_1.assertParamExists)('getOpcoPositions', 'entityId', entityId);
            const localVarPath = `/arenas/{arena_id}/entities/{entity_id}/opco_positions`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (excludeInactive !== undefined) {
                localVarQueryParameter['exclude_inactive'] = excludeInactive;
            }
            if (asOfDate !== undefined) {
                localVarQueryParameter['as_of_date'] = asOfDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions by ids with account, investor group, and investment entity ids.
         * @summary Gets positions by ids with account, investor group, and investment entity ids.
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [positionIds] Comma separated list of position ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionsAttributes: async (arenaId, positionIds, options = {}) => {
            // verify required parameter 'arenaId' is not null or undefined
            (0, common_1.assertParamExists)('getPositionsAttributes', 'arenaId', arenaId);
            const localVarPath = `/arenas/{arena_id}/positions_attributes`
                .replace(`{${"arena_id"}}`, encodeURIComponent(String(arenaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (positionIds) {
                localVarQueryParameter['position_ids'] = positionIds.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PositionsApiAxiosParamCreator = PositionsApiAxiosParamCreator;
/**
 * PositionsApi - functional programming interface
 * @export
 */
const PositionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PositionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Gets position of a specific arena and source
         * @summary Gets position of a specific arena and source
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalPosition(arenaId, externalPositionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalPosition(arenaId, externalPositionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PositionsApi.getExternalPosition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
         * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} entityId Id of the entity
         * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
         * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PositionsApi.getOpcoPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets positions by ids with account, investor group, and investment entity ids.
         * @summary Gets positions by ids with account, investor group, and investment entity ids.
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [positionIds] Comma separated list of position ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionsAttributes(arenaId, positionIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionsAttributes(arenaId, positionIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PositionsApi.getPositionsAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PositionsApiFp = PositionsApiFp;
/**
 * PositionsApi - factory interface
 * @export
 */
const PositionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PositionsApiFp)(configuration);
    return {
        /**
         * Gets position of a specific arena and source
         * @summary Gets position of a specific arena and source
         * @param {number} arenaId Id of the arena to operate within
         * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalPosition(arenaId, externalPositionId, options) {
            return localVarFp.getExternalPosition(arenaId, externalPositionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
         * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
         * @param {number} arenaId Id of the arena to operate within
         * @param {number} entityId Id of the entity
         * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
         * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options) {
            return localVarFp.getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets positions by ids with account, investor group, and investment entity ids.
         * @summary Gets positions by ids with account, investor group, and investment entity ids.
         * @param {number} arenaId Id of the arena to operate within
         * @param {Array<string>} [positionIds] Comma separated list of position ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionsAttributes(arenaId, positionIds, options) {
            return localVarFp.getPositionsAttributes(arenaId, positionIds, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PositionsApiFactory = PositionsApiFactory;
/**
 * PositionsApi - object-oriented interface
 * @export
 * @class PositionsApi
 * @extends {BaseAPI}
 */
class PositionsApi extends base_1.BaseAPI {
    /**
     * Gets position of a specific arena and source
     * @summary Gets position of a specific arena and source
     * @param {number} arenaId Id of the arena to operate within
     * @param {string} externalPositionId Url safe base64 encoded version of url encoded version of source_name:url encoded version of source_object_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    getExternalPosition(arenaId, externalPositionId, options) {
        return (0, exports.PositionsApiFp)(this.configuration).getExternalPosition(arenaId, externalPositionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an un-paginated list of the entity\'s positions in its directly-owned operating companies.
     * @summary Get a list of the entity\'s positions in its directly-owned operating companies.
     * @param {number} arenaId Id of the arena to operate within
     * @param {number} entityId Id of the entity
     * @param {boolean} [excludeInactive] Whether to exclude inactive objects from the response.
     * @param {string} [asOfDate] An end date of a period. Format should be YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options) {
        return (0, exports.PositionsApiFp)(this.configuration).getOpcoPositions(arenaId, entityId, excludeInactive, asOfDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets positions by ids with account, investor group, and investment entity ids.
     * @summary Gets positions by ids with account, investor group, and investment entity ids.
     * @param {number} arenaId Id of the arena to operate within
     * @param {Array<string>} [positionIds] Comma separated list of position ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    getPositionsAttributes(arenaId, positionIds, options) {
        return (0, exports.PositionsApiFp)(this.configuration).getPositionsAttributes(arenaId, positionIds, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PositionsApi = PositionsApi;
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the transaction rollup status for a specified batch ID.
         * @summary Retrieve a single transaction rollup status by batch ID
         * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatus: async (syncId, options = {}) => {
            // verify required parameter 'syncId' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionRollupStatus', 'syncId', syncId);
            const localVarPath = `/transaction-rollups/{sync_id}`
                .replace(`{${"sync_id"}}`, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of transaction rollup statuses based on the provided batch IDs.
         * @summary Retrieves the status of transaction rollups by batch IDs
         * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatuses: async (syncIds, options = {}) => {
            // verify required parameter 'syncIds' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionRollupStatuses', 'syncIds', syncIds);
            const localVarPath = `/transaction-rollups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (syncIds) {
                localVarQueryParameter['sync_ids'] = syncIds;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TransactionsApiAxiosParamCreator = TransactionsApiAxiosParamCreator;
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns the transaction rollup status for a specified batch ID.
         * @summary Retrieve a single transaction rollup status by batch ID
         * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRollupStatus(syncId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRollupStatus(syncId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TransactionsApi.getTransactionRollupStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of transaction rollup statuses based on the provided batch IDs.
         * @summary Retrieves the status of transaction rollups by batch IDs
         * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRollupStatuses(syncIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRollupStatuses(syncIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TransactionsApi.getTransactionRollupStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TransactionsApiFp = TransactionsApiFp;
/**
 * TransactionsApi - factory interface
 * @export
 */
const TransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionsApiFp)(configuration);
    return {
        /**
         * Returns the transaction rollup status for a specified batch ID.
         * @summary Retrieve a single transaction rollup status by batch ID
         * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatus(syncId, options) {
            return localVarFp.getTransactionRollupStatus(syncId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of transaction rollup statuses based on the provided batch IDs.
         * @summary Retrieves the status of transaction rollups by batch IDs
         * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRollupStatuses(syncIds, options) {
            return localVarFp.getTransactionRollupStatuses(syncIds, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionsApiFactory = TransactionsApiFactory;
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends base_1.BaseAPI {
    /**
     * Returns the transaction rollup status for a specified batch ID.
     * @summary Retrieve a single transaction rollup status by batch ID
     * @param {string} syncId The synchronization ID to fetch the transaction rollup status for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionRollupStatus(syncId, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getTransactionRollupStatus(syncId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of transaction rollup statuses based on the provided batch IDs.
     * @summary Retrieves the status of transaction rollups by batch IDs
     * @param {Array<string>} syncIds A list of synchronization IDs (UUIDs) to fetch the transaction rollups statuses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionRollupStatuses(syncIds, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getTransactionRollupStatuses(syncIds, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionsApi = TransactionsApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns account IDs that the user has edit access to.
         * @summary Get accounts with edit access
         * @param {number} userId User ID of the resource
         * @param {Array<number>} [accountIds] Comma separated list of account ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsEditAccess: async (userId, accountIds, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountsEditAccess', 'userId', userId);
            const localVarPath = `/users/{user_id}/account-contact/edit-access`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get roles for each areana
         * @summary Get roles for each arena
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserArenaRoles: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserArenaRoles', 'userId', userId);
            const localVarPath = `/users/{user_id}/arena_roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
         * @summary Get distribution batch with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatch: async (userId, distributionBatchId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserDistributionBatch', 'userId', userId);
            // verify required parameter 'distributionBatchId' is not null or undefined
            (0, common_1.assertParamExists)('getUserDistributionBatch', 'distributionBatchId', distributionBatchId);
            const localVarPath = `/users/{user_id}/distribution_batch/{distribution_batch_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"distribution_batch_id"}}`, encodeURIComponent(String(distributionBatchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
         * @summary Get distribution batch distributions for a user_id with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatchDistributions: async (userId, distributionBatchId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserDistributionBatchDistributions', 'userId', userId);
            // verify required parameter 'distributionBatchId' is not null or undefined
            (0, common_1.assertParamExists)('getUserDistributionBatchDistributions', 'distributionBatchId', distributionBatchId);
            const localVarPath = `/users/{user_id}/distribution_batch/{distribution_batch_id}/distributions`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"distribution_batch_id"}}`, encodeURIComponent(String(distributionBatchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
         * @summary Get users
         * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (globalIds, ids, options = {}) => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (globalIds) {
                localVarQueryParameter['global_ids'] = globalIds.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns account IDs that the user has edit access to.
         * @summary Get accounts with edit access
         * @param {number} userId User ID of the resource
         * @param {Array<number>} [accountIds] Comma separated list of account ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsEditAccess(userId, accountIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsEditAccess(userId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getAccountsEditAccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get roles for each areana
         * @summary Get roles for each arena
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserArenaRoles(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserArenaRoles(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getUserArenaRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
         * @summary Get distribution batch with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDistributionBatch(userId, distributionBatchId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDistributionBatch(userId, distributionBatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getUserDistributionBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
         * @summary Get distribution batch distributions for a user_id with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDistributionBatchDistributions(userId, distributionBatchId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDistributionBatchDistributions(userId, distributionBatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getUserDistributionBatchDistributions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
         * @summary Get users
         * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(globalIds, ids, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(globalIds, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UsersApiFp)(configuration);
    return {
        /**
         * Returns account IDs that the user has edit access to.
         * @summary Get accounts with edit access
         * @param {number} userId User ID of the resource
         * @param {Array<number>} [accountIds] Comma separated list of account ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsEditAccess(userId, accountIds, options) {
            return localVarFp.getAccountsEditAccess(userId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get roles for each areana
         * @summary Get roles for each arena
         * @param {number} userId User ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserArenaRoles(userId, options) {
            return localVarFp.getUserArenaRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
         * @summary Get distribution batch with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatch(userId, distributionBatchId, options) {
            return localVarFp.getUserDistributionBatch(userId, distributionBatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
         * @summary Get distribution batch distributions for a user_id with authorization checks
         * @param {number} userId User ID of the resource
         * @param {number} distributionBatchId Id of the distribution_batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDistributionBatchDistributions(userId, distributionBatchId, options) {
            return localVarFp.getUserDistributionBatchDistributions(userId, distributionBatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
         * @summary Get users
         * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
         * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(globalIds, ids, options) {
            return localVarFp.getUsers(globalIds, ids, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * Returns account IDs that the user has edit access to.
     * @summary Get accounts with edit access
     * @param {number} userId User ID of the resource
     * @param {Array<number>} [accountIds] Comma separated list of account ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAccountsEditAccess(userId, accountIds, options) {
        return (0, exports.UsersApiFp)(this.configuration).getAccountsEditAccess(userId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get roles for each areana
     * @summary Get roles for each arena
     * @param {number} userId User ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserArenaRoles(userId, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUserArenaRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a distribution batch by ID. This does handle auth checks (object and role based permissions)
     * @summary Get distribution batch with authorization checks
     * @param {number} userId User ID of the resource
     * @param {number} distributionBatchId Id of the distribution_batch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserDistributionBatch(userId, distributionBatchId, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUserDistributionBatch(userId, distributionBatchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an un-paginated list of distributions that a user_id is authorized to view taking into account both role-based and object-level permissioning.
     * @summary Get distribution batch distributions for a user_id with authorization checks
     * @param {number} userId User ID of the resource
     * @param {number} distributionBatchId Id of the distribution_batch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserDistributionBatchDistributions(userId, distributionBatchId, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUserDistributionBatchDistributions(userId, distributionBatchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an un-paginated list of users filtered by a required list of either DB or global user IDs.
     * @summary Get users
     * @param {Array<string>} [globalIds] Optional comma separated list of global ids to filter resources by.
     * @param {Array<number>} [ids] Optional comma separated list of ids to filter resources by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsers(globalIds, ids, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsers(globalIds, ids, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
